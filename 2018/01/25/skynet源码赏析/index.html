<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>


    <meta name="description" content="终于能搭建自己的博客，好开森！" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="Bobo’s Notes" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description" content="title: skynet源码赏析date: 2018-01-25 00:50:38tags:
- skynet
- 游戏服务器
- c lua
写在最前面skynet是目前使用比较广泛的服务端框架，虽然目前网上资料众多，但是从自己的学习和使用经历来看，缺乏能够让自己系统了解该框架底层机制的资料，这段时间，趁着自己有时间，阅读了skynet底层的一些代码，现在将自己理解的部分总结并记录下来，以备日">
<meta property="og:type" content="article">
<meta property="og:title" content="Bobo’s Notes">
<meta property="og:url" content="http://blog.shixbo.com/2018/01/25/skynet源码赏析/index.html">
<meta property="og:site_name" content="Bobo’s Notes">
<meta property="og:description" content="title: skynet源码赏析date: 2018-01-25 00:50:38tags:
- skynet
- 游戏服务器
- c lua
写在最前面skynet是目前使用比较广泛的服务端框架，虽然目前网上资料众多，但是从自己的学习和使用经历来看，缺乏能够让自己系统了解该框架底层机制的资料，这段时间，趁着自己有时间，阅读了skynet底层的一些代码，现在将自己理解的部分总结并记录下来，以备日">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/002skynet_message_transfer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/001skynet_folder_architecture.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/005socket_listen.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/006socket_accept.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/007socket_recv.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/008socket_send.png">
<meta property="og:updated_time" content="2018-01-24T16:57:53.727Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bobo’s Notes">
<meta name="twitter:description" content="title: skynet源码赏析date: 2018-01-25 00:50:38tags:
- skynet
- 游戏服务器
- c lua
写在最前面skynet是目前使用比较广泛的服务端框架，虽然目前网上资料众多，但是从自己的学习和使用经历来看，缺乏能够让自己系统了解该框架底层机制的资料，这段时间，趁着自己有时间，阅读了skynet底层的一些代码，现在将自己理解的部分总结并记录下来，以备日">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

    <title>  // Bobo’s Notes </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column page-post-detail">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Bobo’s Notes</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
<form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'QNTbmA1YTa4Zhom5hmdT','2.0.0');
</script>

<div class="site-search-toggle"></div>
    </div>
  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2018-01-25T00:57:53+08:00" content="2018-01-25">
            2018-01-25
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2018/01/25/skynet源码赏析/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2018/01/25/skynet源码赏析/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>title: skynet源码赏析<br>date: 2018-01-25 00:50:38<br>tags:</p>
<pre><code>-<span class="ruby"> skynet
</span>-<span class="ruby"> 游戏服务器
</span>-<span class="ruby"> c lua</span>
</code></pre><h4 id="写在最前面">写在最前面</h4><p>skynet是目前使用比较广泛的服务端框架，虽然目前网上资料众多，但是从自己的学习和使用经历来看，缺乏能够让自己系统了解该框架底层机制的资料，这段时间，趁着自己有时间，阅读了skynet底层的一些代码，现在将自己理解的部分总结并记录下来，以备日后使用。本文旨在捋清skynet框架的结构和主要流程，并不会涉及skynet的方方面面，一些论述，我贴上了一些源码加以论证，并在引用的源码里加入了一些注释。对于一些概念，我也本着严谨的原则，尽可能注明了引证来源的出处，引证自维基百科的内容，基本上是没有争议的词条。由于本人水平有限，如果发现文中内容有错误的地方，或者写的不好的地方，欢迎大家批评指正。</p>
<h4 id="对于skynet，需要屡清楚的几个问题">对于skynet，需要屡清楚的几个问题</h4><ul>
<li>skynet本质上解决什么问题？</li>
<li>skynet有哪些基本的数据结构？</li>
<li>skynet有几类线程，他们分别的作用是什么？</li>
<li>skynet如何启动一个c服务？</li>
<li>skynet消息调度机制是怎样的？</li>
<li>skynet如何启动一个lua服务？</li>
<li>skynet的lua层消息派发机制是怎样的？</li>
<li>timer是如何产生消息的？他的结构和流程是怎样的？</li>
<li>网络模块是如何产生消息的？他的结构和流程是怎样的？</li>
<li>skynet有哪些基本服务，他们的作用分别是什么？</li>
<li>skynet集群机制</li>
</ul>
<h4 id="Overview">Overview</h4><p>对于skynet的概述，建议大家先阅读云风大侠的《<a href="http://blog.codingnow.com/2012/09/the_design_of_skynet.html" target="_blank" rel="external">skynet设计综述</a>》。<br>skynet本质是什么？它为我们提供了什么机制？如何正确使用它？我们希望自己写的不同的业务逻辑，独立运行在不同的上下文环境中，并且能够通过某种方式，相互协作，最终共同服务于我们的玩家。skynet则为我们提供了这种环境：</p>
<ul>
<li>我们编写好的c文件，在编译成so库以后，在某个时机，调用该so库api的句柄，会被加载到一个modules列表中，一般这样的模块会被要求定义4种接口create，init，signal和release</li>
<li>我们要创建一个新的，运行该业务逻辑的上下文环境时，则从modules列表中，找到对应的so库句柄，并且调用create接口，创建一个该类业务模块的数据实例，并且创建一个上下文环境（context），引用该类业务的接口和数据实例，该context会被存放在一个统一存放context的列表中，这种context被称之为服务</li>
<li>一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。</li>
<li>skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的</li>
<li>socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，push函数内有加一个自旋锁，避免同时多条线程同时向一个次级消息队列push消息的惨局。<br>综上所述，我们可以将skynet的机制，用一张图概括<br><img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/002skynet_message_transfer.png" alt="image">图1<br>从上面讨论可以得出如下结论，我们所写的不同的业务逻辑，可以运行在不同的独立的沙盒环境中，他们之间是通过消息队列来进行交互的。worker、timer和socket线程里运行的模块，都有机会向特定的服务push消息，他们是消息的生产者，而worker线程内的模块，同时也是消息的消费者（确切的说，应该是那些服务）<br>注意：服务模块要将数据，通过socket发送给客户端时，并不是将数据写入消息队列，而是通过管道从worker线程，发送给socket线程，并交由socket转发。此外，设置定时器也不走消息队列，而是直接将在定时器模块，加入一个timer_node。其实这样也很好理解，因为timer和socket线程内运行的模块并不是这里的context，因此消息队列他们无法消费。<br>在overview中，我们讨论了skynet的部分核心机制（如消息调度），很多细节并未展开仔细去讨论，不过本节的目标就是为了树立一个宏观的概述，后面的内容，将基于此框架更加深入的进行讨论与研究。对于本文，我极力避免贴大段的代码，因为大段的代码，只会让我们迷失在汪洋大海之中，只有在必要的地方，才会贴上代码加以论述。<br>此外，上面的论述，只涉及到c服务模块，并未讨论lua服务的内容，我们所有的lua服务，均是依附于一个叫snlua的c模块来运行的，lua服务每次收到一个消息，就会产生一个协程（事实上，skynet每个服务均有一个协程池，lua服务收到消息时，会优先去池子里取一个协程出来，这里为了理解方便，就视为收到一个消息，就创建一个协程吧），并通过协程执行注册函数，这些内容会在后面进行讨论。</li>
</ul>
<h4 id="skynet基本结构">skynet基本结构</h4><p>1.skynet目录结构<br>学习一个开源框架，首先要做的就是查看目录结构，我们有理由相信，越好的项目，目录组织越合理，结构越清晰，代码目录必然是按照某种规律进行组织，目录组织也是构架的一部分。skynet目录组织如下所示<br><img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/001skynet_folder_architecture.png" alt="image">图2<br>从上面目录结构图来看，越是往下的层次，应用领域越广泛。越是往上的层级，针对性越强，应用领域越小，和业务越相关。</p>
<ul>
<li>3rd目录：提供lua语言支持、 jemalloc（内存管理模块）、md5加密等，这些模块在开发领域有着广泛的应用。  </li>
<li>skynet-src目录：包含skynet最核心机制的模块，包括逻辑入口、加载C服务代码的skynet_module模块、运行和管理服务实例的skynet_context模块、skynet消息队列、定时器和socket模块等。 </li>
<li>service-src目录：这是依附于skynet核心模块的c服务，如用于日志输出的logger服务，用于运行lua脚本snlua的c服务等。  </li>
<li>lualib-src目录：提供C层级的api调用，如调用socket模块的api，调用skynet消息发送，注册回调函数的api，甚至是对C服务的调用等，并导出lua接口，供lua层使用。可以视为lua调C的媒介</li>
<li>service目录：lua层服务，依附于snlua这个c服务，这个目录包含skynet lua层级的一些基本服务，比如启动lua层级服务的bootstrap服务，gate服务，供lua层创建新服务的launcher服务等。</li>
<li>lualib目录：包含调用lua服务的辅助函数，方便应用层调用skynet的一些基本服务；包含对一些c模块或lua模块调用的辅助函数，总之，这些lualib方便应用层调用skynet提供的基本服务，和其他库。  </li>
</ul>
<p>上面的目录基本遵循一个原则，就是上层允许调用下层，而下层不能直接调用上层的api，这样做层次清晰，不会出现你中有我，我中有你的高度耦合的情况存在。c层和lua层耦合的模块则包含在lualib-src中，这种模块划分更利于我们快速寻找对应模块。</p>
<ol>
<li>基本数据结构 </li>
</ol>
<ul>
<li><p>modules管理模块<br>我们所写的C服务在编译成so库以后，会在某个时机被加载到一个modules的列表中，当要创建该类服务的实例时，将从modules列表取出该服务的函数句柄，调用create函数创建服务实例，并且init之后，将实例赋值给一个新的context对象后，注册到图1所示的skynet_context list中，一个新的服务就创建完成了。我们存放modules的模块数据结构如下所示：  </p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skynet_module.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * (*skynet_dl_create)(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*skynet_dl_init)</span><span class="params">(<span class="keyword">void</span> * inst, <span class="keyword">struct</span> skynet_context *, <span class="keyword">const</span> <span class="keyword">char</span> * parm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*skynet_dl_release)</span><span class="params">(<span class="keyword">void</span> * inst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*skynet_dl_signal)</span><span class="params">(<span class="keyword">void</span> * inst, <span class="keyword">int</span> signal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> skynet_module &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * name;          <span class="comment">// C服务名称，一般是C服务的文件名</span></span><br><span class="line">	<span class="keyword">void</span> * module;              <span class="comment">// 访问该so库的dl句柄，该句柄通过dlopen函数获得</span></span><br><span class="line">	skynet_dl_create create;    <span class="comment">// 绑定so库中的<span class="label">xxx_create函数，通过dlsym函数实现绑定，调用该create即是调用xxx_create</span></span></span><br><span class="line">	skynet_dl_init init;        <span class="comment">// 绑定so库中的<span class="label">xxx_init函数，调用该init即是调用xxx_init</span></span></span><br><span class="line">	skynet_dl_release release;  <span class="comment">// 绑定so库中的<span class="label">xxx_release函数，调用该release即是调用xxx_release</span></span></span><br><span class="line">	skynet_dl_signal signal;    <span class="comment">// 绑定so库中的<span class="label">xxx_signal函数，调用该signal即是调用xxx_signal</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skynet_module.c</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_MODULE_TYPE <span class="number">32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> modules &#123;</span><br><span class="line">	<span class="keyword">int</span> count;                  <span class="comment">// modules的数量</span></span><br><span class="line">	<span class="keyword">struct</span> spinlock lock;       <span class="comment">// 自旋锁，避免多个线程同时向skynet_module写入数据，保证线程安全</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * path;          <span class="comment">// 由skynet配置表中的cpath指定，一般包含./cservice/?.so路径</span></span><br><span class="line">	<span class="keyword">struct</span> skynet_module m[MAX_MODULE_TYPE];  <span class="comment">// 存放服务模块的数组，最多32类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> modules * M = <span class="literal">NULL</span>;</span><br><span class="line">```  </span><br><span class="line">通过上面的注释，我们大概可以了解skynet_module结构的作用了，也就是说一个符合规范的skynet c服务，应当包含create，init，signal和release四个接口，在该c服务编译成so库以后，在程序中动态加载到skynet_module列表中，这里通过dlopen函数来获取so库的访问句柄，并通过dlsym将so库中对应的函数绑定到函数指针中，对于两个函数的说明如下所示：</span><br></pre></td></tr></table></figure>
<p>  // 引证来源：<a href="https://linux.die.net/man/3/dlopen" target="_blank" rel="external">https://linux.die.net/man/3/dlopen</a><br>  void <em>dlopen(const char </em>filename, int flag);<br>  void <em>dlsym(void </em>handle, const char *symbol);</p>
<p>  dlopen()<br>  The function dlopen() loads the dynamic library file named by the null-terminated string filename and returns<br>  an opaque “handle” for the dynamic library…</p>
<p>  dlsym()<br>  The function dlsym() takes a “handle” of a dynamic library returned by dlopen() and the null-terminated symbol<br>  name, returning the address where that symbol is loaded into memory…</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    dlopen函数，本质是将so库加载内存中，并返回一个可以访问该内存块的句柄，dlsym，则是通过该句柄和指定一个函数名，到内存中找到指定函数，在内存中的地址，这里将该地址赋值给skynet_module中的<span class="operator"><span class="keyword">create</span>、init、signal或<span class="keyword">release</span>的其中一个函数指针（根据传入的symbol名称，即函数名来定），一个模块被加载以后，将被放置到modules的skynet_module数组中，当要创建该<span class="keyword">module</span>的实例时，将会从skynet_module中取出对应的模块，并调用<span class="keyword">create</span>函数创建实例，然后将实例指针传入init函数完成初始化以后，赋值给<span class="keyword">context</span>。  </span><br><span class="line">    一个<span class="keyword">C</span>服务，定义以上四个接口时，一定要以文件名作为前缀，然后通过下划线和对应函数连接起来，因为skynet加载的时候，就是通过这种方式去寻找对应函数的地址的，比如一个<span class="keyword">c</span>服务文件名为logger，那么对应的<span class="number">4</span>个函数名则为logger_create、logger_init、logger_signal、logger_release。</span><br><span class="line"></span><br><span class="line">* skynet_context管理模块  </span><br><span class="line">    我们创建一个新的服务，首先要先找到对应服务的<span class="keyword">module</span>，在创建完<span class="keyword">module</span>实例并完成初始化以后，还需要创建一个skynet_context上下文，并将<span class="keyword">module</span>实例和<span class="keyword">module</span>模块和这个<span class="keyword">context</span>关联起来，最后放置于skynet_context <span class="keyword">list</span>中，一个个独立的沙盒环境就这样被创建出来了，下面来看主要的数据结构：</span></span><br></pre></td></tr></table></figure>
<p>  // skynet_server.c<br>  struct skynet_context {</p>
<pre><code><span class="type">void</span> * instance;                // 由指定module的create函数，创建的数据实例指针，同一类服务可能有多个实例，
                                // 因此每个服务都应该有自己的数据

struct skynet_module * <span class="keyword">mod</span>;     // 引用服务module的指针，方便后面对create、init、signal和release函数进行调用
<span class="type">void</span> * cb_ud;                   // 调用callback函数时，回传给callback的userdata，一般是instance指针
skynet_cb cb;                   // 服务的消息回调函数，一般在skynet_module的init函数里指定
struct message_queue *queue;    // 服务专属的次级消息队列指针
<span class="type">FILE</span> * logfile;                 // 日志句柄
<span class="type">char</span> <span class="literal">result</span>[<span class="number">32</span>];                // 操作skynet_context的返回值，会写到这里
uint32_t handle;                // 标识唯一context的服务id
<span class="type">int</span> session_id;                 // 在发出请求后，收到对方的返回消息时，通过session_id来匹配一个返回，对应哪个请求
<span class="type">int</span> <span class="keyword">ref</span>;                        // 引用计数变量，当为<span class="number">0</span>时，表示内存可以被释放
<span class="type">bool</span> init;                      // 是否完成初始化
<span class="type">bool</span> endless;                   // 消息是否堵住

<span class="type">CHECKCALLING_DECL</span>
</code></pre><p>  };</p>
<p>  // skynet_handle.c<br>  // 这个结构用于记录，服务对应的别名，当应用层为某个服务命名时，会写到这里来<br>  struct handle_name {</p>
<pre><code><span class="keyword">char</span> * name;                   <span class="comment">// 服务别名</span>
<span class="keyword">uint32_t</span> handle;               <span class="comment">// 服务id</span>
</code></pre><p>  };</p>
<p>  struct handle_storage {</p>
<pre><code><span class="keyword">struct</span> rwlock lock;            <span class="comment">// 读写锁</span>

<span class="keyword">uint32_t</span> harbor;               <span class="comment">// harbor id</span>
<span class="keyword">uint32_t</span> handle_index;         <span class="comment">// 创建下一个服务时，该服务的slot idx，一般会先判断该slot是否被占用，后面会详细讨论</span>
<span class="keyword">int</span> slot_size;                 <span class="comment">// slot的大小，一定是2^n，初始值是4</span>
<span class="keyword">struct</span> skynet_context ** slot; <span class="comment">// skynet_context list</span>

<span class="keyword">int</span> name_cap;                  <span class="comment">// 别名列表大小，大小为2^n</span>
<span class="keyword">int</span> name_count;                <span class="comment">// 别名数量</span>
<span class="keyword">struct</span> handle_name *name;      <span class="comment">// 别名列表</span>
</code></pre><p>  };</p>
<p>  static struct handle_storage *H = NULL;</p>
  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    我们创建一个新的skynet_context时，会往slot列表中放，当一个消息送达一个context时，其<span class="keyword">callback</span>函数就会被调用，<span class="keyword">callback</span>函数一般在module的init函数里指定，调用<span class="keyword">callback</span>函数时，会传入userdata（一般是instance指针），source（发送方的服务id），type（消息类型），msg和sz（数据及其大小），每个服务的<span class="keyword">callback</span>处理各自的逻辑。这里其实可以将modules视为工厂，而skynet_context则是该工厂创建出来的实例，而这些实例，则是通过handle_storage来进行管理。</span><br><span class="line">    </span><br><span class="line">* 消息与消息队列  </span><br><span class="line">    我们的创建的服务，需要通过消息来驱动，而一个服务要获取消息，是从消息队列里取的。skynet包含两级消息队列，一个global_mq，他包含一个head和tail指针，分别指向次级消息队列的头部和尾部，另外还有一个次级消息队列，这个一个单向链表。消息的派发机制是，工作线程，会从global_mq里pop一个次级消息队列来，然后从次级消息队列中，pop出一个消息，并传给context的<span class="keyword">callback</span>函数，在完成驱动以后，再将次级消息队列push回global_mq中，数据结构如下所示：</span><br></pre></td></tr></table></figure>
<p>  // skynet_mq.h<br>  struct skynet_message {</p>
<pre><code><span class="keyword">uint32_t</span> source;            <span class="comment">// 消息发送方的服务地址</span>

<span class="comment">// 如果这是一个回应消息，那么要通过session找回对应的一次请求，在lua层，我们每次调用call的时候，都会往对  </span>
<span class="comment">// 方的消息队列中，push一个消息，并且生成一个session，然后将本地的协程挂起，挂起时，会以session为key，协程句  </span>
<span class="comment">// 柄为值，放入一个table中，当回应消息送达时，通过session找到对应的协程，并将其唤醒。后面章节会详细讨论</span>
<span class="keyword">int</span> session; 

<span class="keyword">void</span> * data;        <span class="comment">// 消息地址</span>
<span class="keyword">size_t</span> sz;          <span class="comment">// 消息大小</span>
</code></pre><p>  };</p>
<p>  // skynet_mq.c<br>  #define DEFAULT_QUEUE_SIZE 64<br>  #define MAX_GLOBAL_MQ 0x10000</p>
<p>  // 0 means mq is not in global mq.<br>  // 1 means mq is in global mq , or the message is dispatching.</p>
<p>  #define MQ_IN_GLOBAL 1<br>  #define MQ_OVERLOAD 1024</p>
<p>  struct message_queue {</p>
<pre><code><span class="comment">// 自旋锁，可能存在多个线程，向同一个队列写入的情况，加上自旋锁避免并发带来的发现，</span>
<span class="comment">//后面会讨论互斥锁，自旋锁，读写锁和条件变量的区别</span>
<span class="keyword">struct</span> spinlock lock;     

<span class="keyword">uint32_t</span> handle;                <span class="comment">// 拥有此消息队列的服务的id</span>
<span class="keyword">int</span> cap;                        <span class="comment">// 消息大小</span>
<span class="keyword">int</span> head;                       <span class="comment">// 头部index</span>
<span class="keyword">int</span> tail;                       <span class="comment">// 尾部index</span>
<span class="keyword">int</span> release;                    <span class="comment">// 是否能释放消息</span>
<span class="keyword">int</span> in_global;                  <span class="comment">// 是否在全局消息队列中，0表示不是，1表示是</span>
<span class="keyword">int</span> overload;                   <span class="comment">// 是否过载</span>
<span class="keyword">int</span> overload_threshold;
<span class="keyword">struct</span> skynet_message *<span class="built_in">queue</span>;   <span class="comment">// 消息队列</span>
<span class="keyword">struct</span> message_queue *next;     <span class="comment">// 下一个次级消息队列的指针</span>
</code></pre><p>  };</p>
<p>  struct global_queue {</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">head</span>;</span>
<span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">tail</span>;</span>
<span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>
</code></pre><p>  };</p>
<p>  static struct global_queue *Q = NULL;</p>
  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面我们已经讨论了，一个服务如何被消息驱动，现在我们来讨论，消息是如何写入到消息队列中去的。我们要向一个服务发消息，最终是通过调用skynet.<span class="keyword">send</span>接口，将消息插入到该服务专属的次级消息队列的，次级消息队列的内容，并不是context结构的一部分（context只是引用了他的指针），因此，在一个服务执行callback的同时，其他服务（可能是多个线程内执行callback的其他服务）可以向它的消息队列里<span class="keyword">push</span>消息，而mq的<span class="keyword">push</span>操作，是加了一个自旋锁，以避免多个线程，同时操作一个消息队列。lua层的skynet.<span class="keyword">send</span>接口，最终会调到c层的skynet_context_push。这个接口实质上，是通过handle将context指针取出来，然后再往消息队列里<span class="keyword">push</span>消息：</span><br></pre></td></tr></table></figure>
<p>  // skynet_server.c<br>  int<br>  skynet_context_push(uint32_t handle, struct skynet_message *message) {</p>
<pre><code><span class="keyword">struct</span> skynet_context * ctx = skynet_handle_grab(handle);
<span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) {
    <span class="keyword">return</span> -<span class="number">1</span>;
}
skynet_mq_push(ctx-&gt;<span class="built_in">queue</span>, message);
skynet_context_release(ctx);

<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>  }</p>
<p>  // skynet_handle.c<br>  struct skynet_context *<br>  skynet_handle_grab(uint32_t handle) {</p>
<pre><code>struct handle_storage *s = H;
struct skynet_context * <span class="literal">result</span> = <span class="type">NULL</span>;

rwlock_rlock(&amp;s-&gt;lock);

uint32_t hash = handle &amp; (s-&gt;slot_size-<span class="number">1</span>);
struct skynet_context * ctx = s-&gt;slot[hash];
<span class="keyword">if</span> (ctx &amp;&amp; skynet_context_handle(ctx) == handle) {
    <span class="literal">result</span> = ctx;
    skynet_context_grab(<span class="literal">result</span>);
}

rwlock_runlock(&amp;s-&gt;lock);

<span class="keyword">return</span> <span class="literal">result</span>;
</code></pre><p>  }</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    因为我们访问一个服务的机会，远大于创建一个服务并写入列表的机会，因此这里用了读写锁，在通过handle获取context指针时，加了一个读取锁，这样当在读取的过程中，同时有新的服务创建，并且存在要扩充skynet_context <span class="built_in">list</span>容量的风险，因此不论如何，他都应当被阻塞住，直到所有的读取锁都释放掉。  </span><br><span class="line">    次级消息队列，实际上是一个数组，并且用两个<span class="keyword">int</span>型数据，分别指向他的头部和尾部（head和tail），不论是head还是tail，当他们的值&gt;=数组尺寸时，都会进行回绕（即从下标为<span class="number">0</span>开始，比如值为数组的size时，会被重新赋值为<span class="number">0</span>），在push操作后，head等于tail意味着队列已满（此时，队列会扩充两倍，并从头到尾重新赋值，此时head指向<span class="number">0</span>，而tail为扩充前，数组的大小），在pop操作后，head等于tail意味着队列已经空了（后面他会从skynet全局消息队列中，被剔除掉）。  </span><br><span class="line">    ![image](https:<span class="comment">//raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/003skynet_mq.png)图3  </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### skynet如何启动一个c服务</span></span><br><span class="line">我们写的c服务在编译成so库以后，在某个时段，会被加载到modules列表中。创建c服务的工作，一般在c层进行，一般会调用skynet_context_new接口，如下所示：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>// skynet_server.c<br>struct skynet_context <em><br>skynet_context_new(const char </em> name, const char <em>param) {<br>    struct skynet_module </em> mod = skynet_module_query(name);</p>
<pre><code><span class="keyword">if</span> (mod == <span class="built_in">NULL</span>)
    <span class="keyword">return</span> <span class="built_in">NULL</span>;

<span class="literal">void</span> *inst = skynet_module_instance_create(mod);
<span class="keyword">if</span> (inst == <span class="built_in">NULL</span>)
    <span class="keyword">return</span> <span class="built_in">NULL</span>;
struct skynet_context * ctx = skynet_malloc(sizeof(*ctx));
CHECKCALLING_INIT(ctx)

ctx<span class="subst">-&gt;</span>mod = mod;
ctx<span class="subst">-&gt;</span>instance = inst;
ctx<span class="subst">-&gt;</span>ref = <span class="number">2</span>;
ctx<span class="subst">-&gt;</span>cb = <span class="built_in">NULL</span>;
ctx<span class="subst">-&gt;</span>cb_ud = <span class="built_in">NULL</span>;
ctx<span class="subst">-&gt;</span>session_id = <span class="number">0</span>;
ctx<span class="subst">-&gt;</span>logfile = <span class="built_in">NULL</span>;

ctx<span class="subst">-&gt;</span>init = <span class="literal">false</span>;
ctx<span class="subst">-&gt;</span>endless = <span class="literal">false</span>;
<span class="comment">// Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle</span>
ctx<span class="subst">-&gt;</span><span class="keyword">handle</span> = <span class="number">0</span>;    
ctx<span class="subst">-&gt;</span><span class="keyword">handle</span> = skynet_handle_register(ctx);
struct message_queue * <span class="built_in">queue</span> = ctx<span class="subst">-&gt;</span><span class="built_in">queue</span> = skynet_mq_create(ctx<span class="subst">-&gt;</span><span class="keyword">handle</span>);
<span class="comment">// init function maybe use ctx-&gt;handle, so it must init at last</span>
context_inc();

CHECKCALLING_BEGIN(ctx)
int r = skynet_module_instance_init(mod, inst, ctx, param);
CHECKCALLING_END(ctx)
<span class="keyword">if</span> (r == <span class="number">0</span>) {
    struct skynet_context * ret = skynet_context_release(ctx);
    <span class="keyword">if</span> (ret) {
        ctx<span class="subst">-&gt;</span>init = <span class="literal">true</span>;
    }
    skynet_globalmq_push(<span class="built_in">queue</span>);
    <span class="keyword">if</span> (ret) {
        skynet_err<span class="subst">or</span>(ret, <span class="string">"LAUNCH %s %s"</span>, name, param ? param : <span class="string">""</span>);
    }
    <span class="keyword">return</span> ret;
} <span class="keyword">else</span> {
    skynet_err<span class="subst">or</span>(ctx, <span class="string">"FAILED launch %s"</span>, name);
    uint32_t <span class="keyword">handle</span> = ctx<span class="subst">-&gt;</span><span class="keyword">handle</span>;
    skynet_context_release(ctx);
    skynet_handle_retire(<span class="keyword">handle</span>);
    struct drop_t d = { <span class="keyword">handle</span> };
    skynet_mq_release(<span class="built_in">queue</span>, drop_message, <span class="subst">&amp;</span>d);
    <span class="keyword">return</span> <span class="built_in">NULL</span>;
}
</code></pre><p>}</p>
<p>// skynet_module.c<br>struct skynet_module <em><br>skynet_module_query(const char </em> name) {<br>    struct skynet_module * result = _query(name);<br>    if (result)<br>        return result;</p>
<pre><code><span class="type">SPIN_LOCK</span>(M)

<span class="literal">result</span> = _query(name); // double check

<span class="keyword">if</span> (<span class="literal">result</span> == <span class="type">NULL</span> &amp;&amp; M-&gt;count &lt; <span class="type">MAX_MODULE_TYPE</span>) {
    <span class="type">int</span> index = M-&gt;count;
    <span class="type">void</span> * dl = _try_open(M,name);
    <span class="keyword">if</span> (dl) {
        M-&gt;m[index].name = name;
        M-&gt;m[index].module = dl;

        <span class="keyword">if</span> (_open_sym(&amp;M-&gt;m[index]) == <span class="number">0</span>) {
            M-&gt;m[index].name = skynet_strdup(name);
            M-&gt;count ++;
            <span class="literal">result</span> = &amp;M-&gt;m[index];
        }
    }
}

<span class="type">SPIN_UNLOCK</span>(M)

<span class="keyword">return</span> <span class="literal">result</span>;
</code></pre><p>}</p>
<p>static void <em><br>_try_open(struct modules </em>m, const char <em> name) {<br>    const char </em>l;<br>    const char * path = m-&gt;path;<br>    size_t path_size = strlen(path);<br>    size_t name_size = strlen(name);</p>
<pre><code><span class="keyword">int</span> sz = path_size + name_size;
<span class="comment">//search path</span>
<span class="keyword">void</span> * dl = <span class="literal">NULL</span>;
<span class="keyword">char</span> tmp[sz];
<span class="keyword">do</span>
{
    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,sz);
    <span class="keyword">while</span> (*path == <span class="string">';'</span>) path++;
    <span class="keyword">if</span> (*path == <span class="string">'\0'</span>) <span class="keyword">break</span>;
    l = <span class="built_in">strchr</span>(path, <span class="string">';'</span>);
    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) l = path + <span class="built_in">strlen</span>(path);
    <span class="keyword">int</span> len = l - path;
    <span class="keyword">int</span> i;
    <span class="keyword">for</span> (i=<span class="number">0</span>;path[i]!=<span class="string">'?'</span> &amp;&amp; i &lt; len ;i++) {
        tmp[i] = path[i];
    }
    <span class="built_in">memcpy</span>(tmp+i,name,name_size);
    <span class="keyword">if</span> (path[i] == <span class="string">'?'</span>) {
        <span class="built_in">strncpy</span>(tmp+i+name_size,path+i+<span class="number">1</span>,len - i - <span class="number">1</span>);
    } <span class="keyword">else</span> {
        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Invalid C service path\n"</span>);
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    dl = dlopen(tmp, RTLD_NOW | RTLD_GLOBAL);
    path = l;
}<span class="keyword">while</span>(dl == <span class="literal">NULL</span>);

<span class="keyword">if</span> (dl == <span class="literal">NULL</span>) {
    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"try open %s failed : %s\n"</span>,name,dlerror());
}

<span class="keyword">return</span> dl;
</code></pre><p>}</p>
<p>_open_sym(struct skynet_module *mod) {<br>    size_t name_size = strlen(mod-&gt;name);<br>    char tmp[name_size + 9]; // create/init/release/signal , longest name is release (7)<br>    memcpy(tmp, mod-&gt;name, name_size);<br>    strcpy(tmp+name_size, “_create”);<br>    mod-&gt;create = dlsym(mod-&gt;module, tmp);<br>    strcpy(tmp+name_size, “_init”);<br>    mod-&gt;init = dlsym(mod-&gt;module, tmp);<br>    strcpy(tmp+name_size, “_release”);<br>    mod-&gt;release = dlsym(mod-&gt;module, tmp);<br>    strcpy(tmp+name_size, “_signal”);<br>    mod-&gt;signal = dlsym(mod-&gt;module, tmp);</p>
<pre><code><span class="keyword">return</span> <span class="built_in">mod</span>-&gt;init == <span class="literal">NULL</span><span class="comment">;</span>
</code></pre><p>}<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们要创建一个c服务，首先要获取对应c服务的模块对象，在上一节中，我们已经介绍了skynet的modules对象，它包含skynet_module列表，so库所在路径，创建一个c服务，一般要经历下面几个步骤：  </span><br><span class="line">1. 从modules列表中，查找对应的服务模块，如果找到则返回，否则到modules的path中去查找对应的so库，创建一个skynet_module对象（数据结构见上节），将so库加载到内存，并将访问该so库的句柄和skynet_module对象关联（_try_open做了这件事），并将so库中的xxx_create，xxx_init，xxx_signal，xxx_release四个函数地址赋值给skynet_module的<span class="operator"><span class="keyword">create</span>、init、signal和<span class="keyword">release</span>四个函数中，这样这个skynet_module对象，就能调用so库中，对应的四个接口（_open_sym做了这件事）。</span><br><span class="line"><span class="number">2.</span> 创建一个服务实例即skynet_context对象，他包含一个次级消息队列指针，服务模块指针（skynet_module对象，便于他访问<span class="keyword">module</span>自定义的<span class="keyword">create</span>、init、signal和<span class="keyword">release</span>函数），由服务模块调用<span class="keyword">create</span>接口创建的数据实例等。</span><br><span class="line"><span class="number">3.</span> 将新创建的服务实例（skynet_context对象）注册到全局的服务列表中（见上节的handle_storage结构）。</span><br><span class="line"><span class="number">4.</span> 初始化服务模块（skynet_module创建的数据实例），并在初始化函数中，注册新创建的skynet_context实例的callback函数</span><br><span class="line"><span class="number">5.</span> 将该服务实例（skynet_context实例）的次级消息队列，插入到全局消息队列中。  </span><br><span class="line">经过上面的步骤，一个<span class="keyword">c</span>服务模块就被创建出来了，在回调函数被指定以后，其他服务发送给他的消息，会被pop出来，最终传给服务对应的callback函数，最后达到驱动服务的目的。  </span><br><span class="line">  </span><br><span class="line">下面通过创建logger服务的例子，来进行说明，以下例子请结合图<span class="number">1</span>来看（假设一开始modules列表中没有logger模块，skynet_context <span class="keyword">list</span>中没有logger的服务实例）：</span><br><span class="line"><span class="number">1.</span> 启动skynet节点时，会启动一个logger <span class="keyword">c</span>服务</span></span><br></pre></td></tr></table></figure></p>
<p>// skynet_start.c<br>void<br>skynet_start(struct skynet_config * config) {<br>    …</p>
<pre><code><span class="keyword">struct</span> skynet_context *ctx = skynet_context_new(config-&gt;logservice, config-&gt;logger);
<span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) {
    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't launch %s service\n"</span>, config-&gt;logservice);
    <span class="built_in">exit</span>(<span class="number">1</span>);
}

...
</code></pre><p>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其中配置中的logservice指名<span class="built_in">log</span>服务的so库名称，用于后面加载服务时使用，后面的logger字段则指定<span class="built_in">log</span>的输出路径。</span><br><span class="line"><span class="number">2.</span> 此时，在图<span class="number">1</span>中的skynet_module列表中，搜索logger服务模块，如果没找到则在so库的输出路径中，寻找名为logger的so库，找到则将该so库加载到内存中，并将对应的logger_create,logger_init,logger_release函数地址分别赋值给logger模块中的create,init,release函数指针，此时图<span class="number">1</span>中的skynet_module列表中，多了一个logger模块。</span><br><span class="line"><span class="number">3.</span> 创建服务实例，即创建一个skynet_context实例，为了使skynet_context实例拥有访问logger服务内部函数的权限，这里将logger模块指针，赋值给skynet_context实例的mod变量中。</span><br><span class="line"><span class="number">4.</span> 创建一个logger服务的数据实例，调用logger服务的create函数：</span><br></pre></td></tr></table></figure></p>
<p>// service_logger.c<br>struct logger {<br>    FILE * handle;<br>    int close;<br>};</p>
<p>struct logger <em><br>logger_create(void) {<br>    struct logger </em> inst = skynet_malloc(sizeof(*inst));<br>    inst-&gt;handle = NULL;<br>    inst-&gt;close = 0;<br>    return inst;<br>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时，将新创建的数据实例赋值给skynet_context的instance变量，此时，一个服务对象运行时，所要用到的逻辑，能够通过mod变量，访问logger服务对应的函数，而通过instance可以找到该服务自己的数据块。</span><br><span class="line"><span class="number">5.</span> 将新创建的skynet_context对象，注册到图一的skynet_context <span class="built_in">list</span>中，此时skynet_context <span class="built_in">list</span>多了一个logger服务实例</span><br><span class="line"><span class="number">6.</span> 初始化logger服务，注册logger服务的callback函数：</span><br></pre></td></tr></table></figure></p>
<p>// service_logger.c<br>static int<br>_logger(struct skynet_context <em> context, void </em>ud, int type, int session, uint32_t source, const void <em> msg, size_t sz) {<br>    struct logger </em> inst = ud;<br>    fprintf(inst-&gt;handle, “[:%08x] “,source);<br>    fwrite(msg, sz , 1, inst-&gt;handle);<br>    fprintf(inst-&gt;handle, “\n”);<br>    fflush(inst-&gt;handle);</p>
<pre><code><span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}</p>
<p>int<br>logger_init(struct logger <em> inst, struct skynet_context </em>ctx, const char * parm) {<br>    if (parm) {<br>        inst-&gt;handle = fopen(parm,”w”);<br>        if (inst-&gt;handle == NULL) {<br>            return 1;<br>        }<br>        inst-&gt;close = 1;<br>    } else {<br>        inst-&gt;handle = stdout;<br>    }<br>    if (inst-&gt;handle) {<br>        skynet_callback(ctx, inst, _logger);<br>        skynet_command(ctx, “REG”, “.logger”);<br>        return 0;<br>    }<br>    return 1;<br>}</p>
<p>// skynet_server.c<br>void<br>skynet_callback(struct skynet_context <em> context, void </em>ud, skynet_cb cb) {<br>    context-&gt;cb = cb;<br>    context-&gt;cb_ud = ud;<br>}<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">上面这段逻辑，将skynet_context的callback函数设置为logger服务的<span class="title">_logger</span>函数，并将调用callback时，传入的userdata设置为先前创建的数据实例</span><br><span class="line"><span class="number">7.</span> 为logger服务实例创建一个次级消息队列，并将队列插入到全局消息队列中  </span><br><span class="line"></span><br><span class="line">从上面的例子，我们就完成了一个logger服务的创建了，当logger服务收到消息时，就会调用<span class="title">_logger</span>函数来进行处理，并将日志输出</span><br><span class="line"></span><br><span class="line"><span class="comment">#### skynet消息调度机制</span></span><br><span class="line">上一节讨论了c服务的创建，现在来讨论消息的派发和消费，本节会讨论skynet的消息派发和消费，以及它如何实现线程安全，要彻底弄清楚这些内容，需要先理解以下四种锁。  </span><br><span class="line">* 互斥锁、自旋锁、读写锁和条件变量</span><br><span class="line">    * 互斥锁（mutex lock : **mut**ual **ex**clusion lock）  </span><br><span class="line">    <span class="number">1.</span> 概念：互斥锁，一条线程加锁锁住临界区，另一条线程尝试访问改临界区的时候，会发生阻塞，并进入休眠状态。临界区是锁lock和unlock之间的代码片段，一般是多条线程能够共同访问的部分。  </span><br><span class="line">    <span class="number">2.</span> 具体说明：假设一台机器上的cpu有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B使用Mutex锁，锁住一个临界区，当线程A试图访问该临界区时，因为线程B已经将其锁住，因此线程A被挂起，进入休眠状态，此时core0进行上下文切换，将线程A放入休眠队列中，然后core0运行线程C，当线程B完成临界区的流程并执行解锁之后，线程A又会被唤醒，core0重新运行线程A  </span><br><span class="line">    <span class="number">3.</span> 引证：维基百科上，[Mutual Exclusion词条](<span class="keyword">https</span>://en.wikipedia.org/wiki/Mutual_exclusion)有一段对互斥锁的解释，一个进程内有两条线程，当一条线程试图访问，被另一条线程锁住的临界区时，那么该线程会阻塞并投入睡眠（suspend）  </span><br><span class="line">    &gt; 引证来源：<span class="keyword">https</span>://en.wikipedia.org/wiki/Mutual_exclusion  Software solution这一节  </span><br><span class="line">    &gt; It is often preferable <span class="built_in">to</span> use synchronization facilities provided <span class="keyword">by</span> <span class="operator">an</span> operating <span class="keyword">system</span><span class="string">'s multithreading library, which will take advantage of hardware solutions if possible but will use software solutions if no hardware solutions exist. For example, when the operating system'</span>s lock library is used <span class="operator">and</span> <span class="operator">a</span> thread tries <span class="built_in">to</span> acquire <span class="operator">an</span> already acquired lock, <span class="operator">the</span> operating <span class="keyword">system</span> could suspend <span class="operator">the</span> thread <span class="keyword">using</span> <span class="operator">a</span> context <span class="keyword">switch</span> <span class="operator">and</span> swap <span class="keyword">it</span> out <span class="operator">with</span> another thread that is ready <span class="built_in">to</span> be run, <span class="operator">or</span> could <span class="built_in">put</span> that processor <span class="keyword">into</span> <span class="operator">a</span> low power state <span class="keyword">if</span> there is no other thread that can be run. Therefore, most modern mutual exclusion methods attempt <span class="built_in">to</span> reduce latency <span class="operator">and</span> busy-waits <span class="keyword">by</span> <span class="keyword">using</span> queuing <span class="operator">and</span> context switches. However, <span class="keyword">if</span> <span class="operator">the</span> <span class="built_in">time</span> that is spent suspending <span class="operator">a</span> thread <span class="operator">and</span> <span class="keyword">then</span> restoring <span class="keyword">it</span> can be proven <span class="built_in">to</span> be always more than <span class="operator">the</span> <span class="built_in">time</span> that must be waited <span class="keyword">for</span> <span class="operator">a</span> thread <span class="built_in">to</span> become ready <span class="built_in">to</span> run <span class="keyword">after</span> being blocked <span class="operator">in</span> <span class="operator">a</span> particular situation, <span class="keyword">then</span> spinlocks are <span class="operator">an</span> acceptable solution (<span class="keyword">for</span> that situation only).[citation needed]  </span><br><span class="line"></span><br><span class="line">    * 自旋锁（spinlock）  </span><br><span class="line">    <span class="number">1.</span> 概念：自旋锁，一条线程加锁锁住临界区，另一条线程尝试访问该临界区的时候，会发生阻塞，但是不会进入休眠状态，并且不断轮询该锁，直至原来锁住临界区的线程解锁。</span><br><span class="line">    <span class="number">2.</span> 具体说明：假设一台机器上有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B调用spin lock锁住临界区，当线程A尝试访问该临界区时，因为B已经加锁，此时线程A会阻塞，并且不断轮询该锁，不会交出core0的使用权，当线程B释放锁时，A开始执行临界区逻辑</span><br><span class="line">    <span class="number">3.</span> 引证：维基百科上，对Spinlock的解释是：  </span><br><span class="line">    &gt; 引证来源：<span class="keyword">https</span>://en.wikipedia.org/wiki/Spinlock  </span><br><span class="line">    &gt; In software engineering, <span class="operator">a</span> spinlock is <span class="operator">a</span> lock which causes <span class="operator">a</span> thread trying <span class="built_in">to</span> acquire <span class="keyword">it</span> <span class="built_in">to</span> simply <span class="built_in">wait</span> <span class="operator">in</span> <span class="operator">a</span> loop (<span class="string">"spin"</span>) <span class="keyword">while</span> repeatedly checking <span class="keyword">if</span> <span class="operator">the</span> lock is available. Since <span class="operator">the</span> thread remains active but is <span class="operator">not</span> performing <span class="operator">a</span> useful task, <span class="operator">the</span> use <span class="operator">of</span> such <span class="operator">a</span> lock is <span class="operator">a</span> kind <span class="operator">of</span> busy waiting. Once acquired, spinlocks will usually be held <span class="keyword">until</span> they are explicitly released, although <span class="operator">in</span> some implementations they may be automatically released <span class="keyword">if</span> <span class="operator">the</span> thread being waited <span class="command"><span class="keyword">on</span> (<span class="title">that</span> <span class="title">which</span> <span class="title">holds</span> <span class="title">the</span> <span class="title">lock</span>) <span class="title">blocks</span>, <span class="title">or</span> <span class="string">"goes to sleep"</span>.  </span></span><br><span class="line">    </span><br><span class="line">    * 读写锁（readers–writer lock）  </span><br><span class="line">    <span class="number">1.</span> 概述：读写锁，一共三种状态  </span><br><span class="line">        * 读状态时加锁，此时为共享锁，当一个线程加了读锁时，其他线程如果也尝试以读模式进入临界区，那么不会发生阻塞，直接访问临界区  </span><br><span class="line">        * 写状态时加锁，此时为独占锁，当某个线程加了写锁，那么其他线程尝试访问该临界区（不论是读还是写），都会阻塞等待  </span><br><span class="line">        * 不加锁</span><br><span class="line">    <span class="number">2.</span> 注意:</span><br><span class="line">        * 某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞</span><br><span class="line">        * 读写锁适合在读远大于写的情形中使用</span><br><span class="line">    <span class="number">3.</span> 引证：维基百科对[rwlock](<span class="keyword">https</span>://en.wikipedia.org/wiki/Readers%E2%<span class="number">80</span>%<span class="number">93</span>writer_lock)的解释是：</span><br><span class="line">    &gt; 引证来源：<span class="keyword">https</span>://en.wikipedia.org/wiki/Readers%E2%<span class="number">80</span>%<span class="number">93</span>writer_lock  </span><br><span class="line">    &gt; In computer science, <span class="operator">a</span> readers–writer (RW) <span class="operator">or</span> shared-exclusive lock (also known <span class="keyword">as</span> <span class="operator">a</span> multiple readers/single-writer lock[<span class="number">1</span>] <span class="operator">or</span> multi-reader lock[<span class="number">2</span>]) is <span class="operator">a</span> synchronization primitive that solves <span class="constant">one</span> <span class="operator">of</span> <span class="operator">the</span> readers–writers problems. An RW lock allows concurrent access <span class="keyword">for</span> <span class="built_in">read</span>-only operations, <span class="keyword">while</span> <span class="built_in">write</span> operations <span class="built_in">require</span> exclusive access. This means that multiple threads can <span class="built_in">read</span> <span class="operator">the</span> data <span class="operator">in</span> parallel but <span class="operator">an</span> exclusive lock is needed <span class="keyword">for</span> writing <span class="operator">or</span> modifying data. When <span class="operator">a</span> writer is writing <span class="operator">the</span> data, all other writers <span class="operator">or</span> readers will be blocked <span class="keyword">until</span> <span class="operator">the</span> writer is finished writing. A common use might be <span class="built_in">to</span> control access <span class="built_in">to</span> <span class="operator">a</span> data structure <span class="operator">in</span> memory that cannot be updated atomically <span class="operator">and</span> is invalid (<span class="operator">and</span> should <span class="operator">not</span> be <span class="built_in">read</span> <span class="keyword">by</span> another thread) <span class="keyword">until</span> <span class="operator">the</span> update is complete.  </span><br><span class="line">    &gt; Readers–writer locks are usually constructed <span class="command"><span class="keyword">on</span> <span class="title">top</span> <span class="title">of</span> <span class="title">mutexes</span> <span class="title">and</span> <span class="title">condition</span> <span class="title">variables</span>, <span class="title">or</span> <span class="title">on</span> <span class="title">top</span> <span class="title">of</span> <span class="title">semaphores</span>.  </span></span><br><span class="line">    </span><br><span class="line">    * 条件变量（condition variables）  </span><br><span class="line">    概述：假设A,B,C三条线程，其中B,C线程加了cond_wait锁并投入睡眠，而A线程则在某个条件触发时，会通过signal通知B,C线程，从而唤醒B和C线程，更多内容请查阅维基百科，[条件变量词条](<span class="keyword">https</span>://en.wikipedia.org/wiki/Monitor_(synchronization)<span class="comment">#Condition_variables)  </span></span><br><span class="line">    </span><br><span class="line">* 消费消息流程  </span><br><span class="line"><span class="number">1.</span> 概述：  </span><br><span class="line">skynet在启动时，会创建若干条worker线程（由配置指定），这些worker线程被创建以后，会不断得从global_mq里pop出一个次级消息队列来，每个worker线程，每次只pop一个次级消息队列，然后再从次级消息队列中，pop一到若干条消息出来（受权重值影响），最后消息将作为参数传给对应服务的callback函数（每个服务只有一个专属的次级消息队列），当callback执行完时，worker线程会将次级消息队列push回global_mq里，这样就完成了消息的消费。  </span><br><span class="line">在这个过程中，因为每个worker线程会从global_mq里pop一个次级消息队列出来，此时其他worker线程就不能从global_mq里pop出同一个次级消息队列，也就是说，一个服务不能同时在多个worker线程内调用callback函数，从而保证了线程安全。</span><br><span class="line"><span class="number">2.</span> worker线程的创建与运作  </span><br><span class="line">    要理解skynet的消息调度，首先要理解worker线程的创建流程，基本运作以及线程安全。worker线程的数量由配置的“thread”字段指定，skynet节点启动时，会创建配置指定数量的worker线程，我们可以再skynet_start.c的<span class="built_in">start</span>函数中找到这个创建流程：</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="comment">// skynet_start.c</span>
<span class="keyword">static</span> void
start(<span class="keyword">int</span> thread) {
    pthread_t pid[thread+<span class="number">3</span>];

    struct monitor *m = skynet_malloc(sizeof(*m));
    memset(m, <span class="number">0</span>, sizeof(*m));
    m-&gt;count = thread;
    m-&gt;sleep = <span class="number">0</span>;

    m-&gt;m = skynet_malloc(thread * sizeof(struct skynet_monitor *));
    <span class="keyword">int</span> i;
    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) {
        m-&gt;m[i] = skynet_monitor_new();
    }
    <span class="keyword">if</span> (pthread_mutex_init(&amp;m-&gt;mutex, <span class="keyword">NULL</span>)) {
        fprintf(stderr, <span class="string">"Init mutex error"</span>);
        <span class="keyword">exit</span>(<span class="number">1</span>);
    }
    <span class="keyword">if</span> (pthread_cond_init(&amp;m-&gt;cond, <span class="keyword">NULL</span>)) {
        fprintf(stderr, <span class="string">"Init cond error"</span>);
        <span class="keyword">exit</span>(<span class="number">1</span>);
    }

    create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);
    create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);
    create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);

    <span class="keyword">static</span> <span class="keyword">int</span> weight[] = { 
        -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
        <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, 
        <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, 
        <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, };
    struct worker_parm wp[thread];
    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) {
        wp[i].m = m;
        wp[i].id = i;
        <span class="keyword">if</span> (i &lt; sizeof(weight)/sizeof(weight[<span class="number">0</span>])) {
            wp[i].weight= weight[i];
        } <span class="keyword">else</span> {
            wp[i].weight = <span class="number">0</span>;
        }
        create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);
    }

    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread+<span class="number">3</span>;i++) {
        pthread_join(pid[i], <span class="keyword">NULL</span>); 
    }

    free_monitor(m);
}
&lt;!--￼<span class="number">9</span>--&gt;

<span class="comment">// skynet_mq.c</span>
void 
skynet_globalmq_push(struct message_queue * queue) {
    struct global_queue *q= Q;

    SPIN_LOCK(q)
    assert(queue-&gt;next == <span class="keyword">NULL</span>);
    <span class="keyword">if</span>(q-&gt;tail) {
        q-&gt;tail-&gt;next = queue;
        q-&gt;tail = queue;
    } <span class="keyword">else</span> {
        q-&gt;head = q-&gt;tail = queue;
    }
    SPIN_UNLOCK(q)
}

struct message_queue * 
skynet_globalmq_pop() {
    struct global_queue *q = Q;

    SPIN_LOCK(q)
    struct message_queue *mq = q-&gt;head;
    <span class="keyword">if</span>(mq) {
        q-&gt;head = mq-&gt;next;
        <span class="keyword">if</span>(q-&gt;head == <span class="keyword">NULL</span>) {
            assert(mq == q-&gt;tail);
            q-&gt;tail = <span class="keyword">NULL</span>;
        }
        mq-&gt;next = <span class="keyword">NULL</span>;
    }
    SPIN_UNLOCK(q)

    <span class="keyword">return</span> mq;
}
&lt;!--￼<span class="number">10</span>--&gt;

<span class="comment">// skynet_start.c</span>
<span class="keyword">static</span> void
wakeup(struct monitor *m, <span class="keyword">int</span> busy) {
    <span class="keyword">if</span> (m-&gt;sleep &gt;= m-&gt;count - busy) {
        <span class="comment">// signal sleep worker, "spurious wakeup" is harmless</span>
        pthread_cond_signal(&amp;m-&gt;cond);
    }
}

<span class="keyword">static</span> void *
thread_timer(void *p) {
    struct monitor * m = p;
    skynet_initthread(THREAD_TIMER);
    <span class="keyword">for</span> (;;) {
        skynet_updatetime();
        CHECK_ABORT
        wakeup(m,m-&gt;count-<span class="number">1</span>);
        usleep(<span class="number">2500</span>);
    }
    <span class="comment">// wakeup socket thread</span>
    skynet_socket_exit();
    <span class="comment">// wakeup all worker thread</span>
    pthread_mutex_lock(&amp;m-&gt;mutex);
    m-&gt;quit = <span class="number">1</span>;
    pthread_cond_broadcast(&amp;m-&gt;cond);
    pthread_mutex_unlock(&amp;m-&gt;mutex);
    <span class="keyword">return</span> <span class="keyword">NULL</span>;
}

<span class="keyword">static</span> void *
thread_worker(void *p) {
    struct worker_parm *wp = p;
    <span class="keyword">int</span> id = wp-&gt;id;
    <span class="keyword">int</span> weight = wp-&gt;weight;
    struct monitor *m = wp-&gt;m;
    struct skynet_monitor *sm = m-&gt;m[id];
    skynet_initthread(THREAD_WORKER);
    struct message_queue * q = <span class="keyword">NULL</span>;
    <span class="keyword">while</span> (!m-&gt;quit) {
        q = skynet_context_message_dispatch(sm, q, weight);
        <span class="keyword">if</span> (q == <span class="keyword">NULL</span>) {
            <span class="keyword">if</span> (pthread_mutex_lock(&amp;m-&gt;mutex) == <span class="number">0</span>) {
                ++ m-&gt;sleep;
                <span class="comment">// "spurious wakeup" is harmless,</span>
                <span class="comment">// because skynet_context_message_dispatch() can be call at any time.</span>
                <span class="keyword">if</span> (!m-&gt;quit)
                    pthread_cond_wait(&amp;m-&gt;cond, &amp;m-&gt;mutex);
                -- m-&gt;sleep;
                <span class="keyword">if</span> (pthread_mutex_unlock(&amp;m-&gt;mutex)) {
                    fprintf(stderr, <span class="string">"unlock mutex error"</span>);
                    <span class="keyword">exit</span>(<span class="number">1</span>);
                }
            }
        }
    }
    <span class="keyword">return</span> <span class="keyword">NULL</span>;
}

<span class="comment">// skynet_server.c</span>
struct message_queue * 
skynet_context_message_dispatch(struct skynet_monitor *sm, struct message_queue *q, <span class="keyword">int</span> weight) {
    <span class="keyword">if</span> (q == <span class="keyword">NULL</span>) {
        q = skynet_globalmq_pop();
        <span class="keyword">if</span> (q==<span class="keyword">NULL</span>)
            <span class="keyword">return</span> <span class="keyword">NULL</span>;
    }

    uint32_t handle = skynet_mq_handle(q);

    struct skynet_context * ctx = skynet_handle_grab(handle);
    <span class="keyword">if</span> (ctx == <span class="keyword">NULL</span>) {
        struct drop_t d = { handle };
        skynet_mq_release(q, drop_message, &amp;d);
        <span class="keyword">return</span> skynet_globalmq_pop();
    }

    <span class="keyword">int</span> i,n=<span class="number">1</span>;
    struct skynet_message msg;

    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) {
        <span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) {
            skynet_context_release(ctx);
            <span class="keyword">return</span> skynet_globalmq_pop();
        } <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) {
            n = skynet_mq_length(q);
            n &gt;&gt;= weight;
        }
        <span class="keyword">int</span> overload = skynet_mq_overload(q);
        <span class="keyword">if</span> (overload) {
            skynet_error(ctx, <span class="string">"May overload, message queue length = %d"</span>, overload);
        }

        skynet_monitor_trigger(sm, msg.source , handle);

        <span class="keyword">if</span> (ctx-&gt;cb == <span class="keyword">NULL</span>) {
            skynet_free(msg.data);
        } <span class="keyword">else</span> {
            dispatch_message(ctx, &amp;msg);
        }

        skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);
    }

    assert(q == ctx-&gt;queue);
    struct message_queue *nq = skynet_globalmq_pop();
    <span class="keyword">if</span> (nq) {
        <span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span>
        <span class="comment">// Else (global mq is empty or block, don't push q back, and return q again (for next dispatch)</span>
        skynet_globalmq_push(q);
        q = nq;
    } 
    skynet_context_release(ctx);

    <span class="keyword">return</span> q;
}

<span class="keyword">static</span> void
dispatch_message(struct skynet_context *ctx, struct skynet_message *msg) {
    assert(ctx-&gt;init);
    CHECKCALLING_BEGIN(ctx)
    pthread_setspecific(G_NODE.handle_key, (void *)(uintptr_t)(ctx-&gt;handle));
    <span class="keyword">int</span> type = msg-&gt;sz &gt;&gt; MESSAGE_TYPE_SHIFT;
    size_t sz = msg-&gt;sz &amp; MESSAGE_TYPE_MASK;
    <span class="keyword">if</span> (ctx-&gt;logfile) {
        skynet_log_output(ctx-&gt;logfile, msg-&gt;source, type, msg-&gt;session, msg-&gt;data, sz);
    }
    <span class="keyword">if</span> (!ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz)) {
        skynet_free(msg-&gt;data);
    } 
    CHECKCALLING_END(ctx)
}
&lt;!--￼<span class="number">11</span>--&gt;

    struct skynet_context * 
    skynet_handle_grab(uint32_t handle) {
        struct handle_storage *s = H;
        struct skynet_context * result = <span class="keyword">NULL</span>;

        rwlock_rlock(&amp;s-&gt;lock);

        uint32_t hash = handle &amp; (s-&gt;slot_size-<span class="number">1</span>);
        struct skynet_context * ctx = s-&gt;slot[hash];
        <span class="keyword">if</span> (ctx &amp;&amp; skynet_context_handle(ctx) == handle) {
            result = ctx;
            skynet_context_grab(result);
        }

        rwlock_runlock(&amp;s-&gt;lock);

        <span class="keyword">return</span> result;
    }
    &lt;!--￼<span class="number">12</span>--&gt;
</code></pre><p>– skynet.lua<br>function skynet.newservice(name, …)<br>    return skynet.call(“.launcher”, “lua” , “LAUNCH”, “snlua”, name, …)<br>end</p>
<p>– launcher.lua<br>local function launch_service(service, …)<br>    local param = table.concat({…}, “ “)<br>    local inst = skynet.launch(service, param)<br>    local response = skynet.response()<br>    if inst then<br>        services[inst] = service .. “ “ .. param<br>        instance[inst] = response<br>    else<br>        response(false)<br>        return<br>    end<br>    return inst<br>end</p>
<p>function command.LAUNCH(_, service, …)<br>    launch_service(service, …)<br>    return NORET<br>end<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时会发送消息给launcher服务，告诉launcher服务，要去创建一个snlua的<span class="built_in">c</span>服务，并且绑定一个lua_State，该lua_State运行名称为name的lua脚本（这个脚本是入口），这里将<span class="built_in">c</span>服务名称、脚本名称和参数，拼成一个字符串，并下传给<span class="built_in">c</span>层</span><br></pre></td></tr></table></figure></p>
<p>– skynet.manager<br>function skynet.launch(…)<br>    local addr = c.command(“LAUNCH”, table.concat({…},” “))<br>    if addr then<br>        return tonumber(“0x” .. string.sub(addr , 2))<br>    end<br>end</p>
<p>// lua-skynet.c<br>static int<br>_command(lua_State <em>L) {<br>    struct skynet_context </em> context = lua_touserdata(L, lua_upvalueindex(1));<br>    const char <em> cmd = luaL_checkstring(L,1);<br>    const char </em> result;<br>    const char * parm = NULL;<br>    if (lua_gettop(L) == 2) {<br>        parm = luaL_checkstring(L,2);<br>    }</p>
<pre><code><span class="literal">result</span> = skynet_command(context, cmd, parm);
<span class="keyword">if</span> (<span class="literal">result</span>) {
    lua_pushstring(L, <span class="literal">result</span>);
    <span class="keyword">return</span> <span class="number">1</span>;
}
<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}</p>
<p>// skynet_server.c<br>static const char <em><br>cmd_launch(struct skynet_context </em> context, const char <em> param) {<br>    size_t sz = strlen(param);<br>    char tmp[sz+1];<br>    strcpy(tmp,param);<br>    char </em> args = tmp;<br>    char <em> mod = strsep(&amp;args, “ \t\r\n”);<br>    args = strsep(&amp;args, “\r\n”);<br>    struct skynet_context </em> inst = skynet_context_new(mod,args);<br>    if (inst == NULL) {<br>        return NULL;<br>    } else {<br>        id_to_hex(context-&gt;result, inst-&gt;handle);<br>        return context-&gt;result;<br>    }<br>}<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此时，我们就已经创建了一个snlua的<span class="built_in">c</span>服务（<span class="built_in">c</span>服务创建流程，上文已经有说明，这里不再赘述），在创建snlua服务的过程中，会对新的snlua服务进行初始化操作</span><br></pre></td></tr></table></figure></p>
<p>// service_snlua.c<br>static int<br>_launch(struct skynet_context <em> context, void </em>ud, int type, int session, uint32_t source , const void <em> msg, size_t sz) {<br>    assert(type == 0 &amp;&amp; session == 0);<br>    struct snlua </em>l = ud;<br>    skynet_callback(context, NULL, NULL);<br>    int err = _init(l, context, msg, sz);<br>    if (err) {<br>        skynet_command(context, “EXIT”, NULL);<br>    }</p>
<pre><code><span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}</p>
<p>int<br>snlua_init(struct snlua <em>l, struct skynet_context </em>ctx, const char <em> args) {<br>    int sz = strlen(args);<br>    char </em> tmp = skynet_malloc(sz);<br>    memcpy(tmp, args, sz);<br>    skynet_callback(ctx, l , _launch);<br>    const char * self = skynet_command(ctx, “REG”, NULL);<br>    uint32_t handle_id = strtoul(self+1, NULL, 16);<br>    // it must be first message<br>    skynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz);<br>    return 0;<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里将_launch作为该snlua服务的callback函数，完成注册以后，向自己发送了一个消息，本snlua服务在接收到消息以后，就会调用_launch函数，此时，snlua服务的回调函数会被赋空值，并进行一次snlua绑定的lu<span class="built_in">a_State</span>的初始化</span><br></pre></td></tr></table></figure></p>
<p>// service_snlua.c<br>static int<br>_init(struct snlua <em>l, struct skynet_context </em>ctx, const char <em> args, size_t sz) {<br>    lua_State </em>L = l-&gt;L;<br>    l-&gt;ctx = ctx;<br>    lua_gc(L, LUA_GCSTOP, 0);<br>    lua_pushboolean(L, 1);  /<em> signal for libraries to ignore env. vars. </em>/<br>    lua_setfield(L, LUA_REGISTRYINDEX, “LUA_NOENV”);<br>    luaL_openlibs(L);<br>    lua_pushlightuserdata(L, ctx);<br>    lua_setfield(L, LUA_REGISTRYINDEX, “skynet_context”);<br>    luaL_requiref(L, “skynet.codecache”, codecache , 0);<br>    lua_pop(L,1);</p>
<pre><code><span class="keyword">const</span> <span class="keyword">char</span> *path = optstring(ctx, <span class="string">"lua_path"</span>,<span class="string">"./lualib/?.lua;./lualib/?/init.lua"</span>);
lua_pushstring(<span class="keyword">L</span>, path);
lua_setglobal(<span class="keyword">L</span>, <span class="string">"LUA_PATH"</span>);
<span class="keyword">const</span> <span class="keyword">char</span> *cpath = optstring(ctx, <span class="string">"lua_cpath"</span>,<span class="string">"./luaclib/?.so"</span>);
lua_pushstring(<span class="keyword">L</span>, cpath);
lua_setglobal(<span class="keyword">L</span>, <span class="string">"LUA_CPATH"</span>);
<span class="keyword">const</span> <span class="keyword">char</span> *service = optstring(ctx, <span class="string">"luaservice"</span>, <span class="string">"./service/?.lua"</span>);
lua_pushstring(<span class="keyword">L</span>, service);
lua_setglobal(<span class="keyword">L</span>, <span class="string">"LUA_SERVICE"</span>);
<span class="keyword">const</span> <span class="keyword">char</span> *preload = skynet_command(ctx, <span class="string">"GETENV"</span>, <span class="string">"preload"</span>);
lua_pushstring(<span class="keyword">L</span>, preload);
lua_setglobal(<span class="keyword">L</span>, <span class="string">"LUA_PRELOAD"</span>);

lua_pushcfunction(<span class="keyword">L</span>, traceback);
<span class="keyword">assert</span>(lua_gettop(<span class="keyword">L</span>) == 1);

<span class="keyword">const</span> <span class="keyword">char</span> * loader = optstring(ctx, <span class="string">"lualoader"</span>, <span class="string">"./lualib/loader.lua"</span>);

int r = luaL_loadfile(<span class="keyword">L</span>,loader);
<span class="keyword">if</span> (r != LUA_OK) {
    skynet_error(ctx, <span class="string">"Can't load %s : %s"</span>, loader, lua_tostring(<span class="keyword">L</span>, -1));
    _report_launcher_error(ctx);
    <span class="keyword">return</span> 1;
}
lua_pushlstring(<span class="keyword">L</span>, <span class="keyword">args</span>, sz);
r = lua_pcall(<span class="keyword">L</span>,1,0,1);
<span class="keyword">if</span> (r != LUA_OK) {
    skynet_error(ctx, <span class="string">"lua loader error : %s"</span>, lua_tostring(<span class="keyword">L</span>, -1));
    _report_launcher_error(ctx);
    <span class="keyword">return</span> 1;
}
lua_settop(<span class="keyword">L</span>,0);

lua_gc(<span class="keyword">L</span>, LUA_GCRESTART, 0);

<span class="keyword">return</span> 0;
</code></pre><p>}<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">c</span>初始化lua_State，先是将服务指针，skynet_context保存起来，以方便<span class="keyword">lua</span>层调<span class="keyword">c</span>的时候使用，然后就是一些配置设置，如设置<span class="keyword">lua</span>服务脚本的存放路径，<span class="keyword">c</span>服务<span class="keyword">so</span>库的存放路径，lualib的存放路径等（加载和调用的时候，回到这些路径里找），然后该lua_State会加载一个用于执行指定脚本的loader.<span class="keyword">lua</span>脚本，并将参数传给这个脚本（参数就是snlua服务绑定的<span class="keyword">lua</span>脚本名称和传给这个脚本的参数拼起来的字符串，比如要启动一个名为scene的服务，那么对应的脚本名称就是scene.<span class="keyword">lua</span>）</span><br></pre></td></tr></table></figure></p>
<p>– lualib.loader.lua<br>local args = {}<br>for word in string.gmatch(…, “%S+”) do<br>    table.insert(args, word)<br>end</p>
<p>SERVICE_NAME = args[1]</p>
<p>local main, pattern</p>
<p>local err = {}<br>for pat in string.gmatch(LUA_SERVICE, “([^;]+);*”) do<br>    local filename = string.gsub(pat, “?”, SERVICE_NAME)<br>    local f, msg = loadfile(filename)<br>    if not f then<br>        table.insert(err, msg)<br>    else<br>        pattern = pat<br>        main = f<br>        break<br>    end<br>end</p>
<p>…</p>
<p>main(select(2, table.unpack(args)))<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">然后，这个lua_State就开始执行这个脚本了，一般来说，<span class="keyword">lua</span>服务的入口脚本，一般可能执行如下几件事情：  </span><br><span class="line">* 定义消息回调函数</span><br><span class="line">* 注册<span class="keyword">lua</span>类型的消息回调函数</span><br><span class="line">* 注册除了<span class="keyword">lua</span>类型以外的其他类型消息处理协议</span><br><span class="line">* 调用skynet.start函数，也就是将skynet.dispatch_message函数注册为<span class="keyword">lua</span>服务的回调函数，所有派发给该<span class="keyword">lua</span>服务的消息，都会传给这个函数；以及在下一帧执行<span class="keyword">lua</span>服务启动逻辑的启动函数（skynet.start函数的第二个参数）  </span><br><span class="line"></span><br><span class="line">skynet的<span class="keyword">lua</span>服务，有一个proto表用于存放不同的消息类型的消息处理协议，一个协议，一般包含以下内容   </span><br><span class="line">* name：表示协议类型的字符串，如<span class="keyword">lua</span>类型，其值则为<span class="string">"lua"</span></span><br><span class="line">* id：标识协议类型的整型值，类型有</span><br></pre></td></tr></table></figure></p>
<p>local skynet = {<br>    – read skynet.h<br>    PTYPE_TEXT = 0,<br>    PTYPE_RESPONSE = 1,<br>    PTYPE_MULTICAST = 2,<br>    PTYPE_CLIENT = 3,<br>    PTYPE_SYSTEM = 4,<br>    PTYPE_HARBOR = 5,<br>    PTYPE_SOCKET = 6,<br>    PTYPE_ERROR = 7,<br>    PTYPE_QUEUE = 8,    – used in deprecated mqueue, use skynet.queue instead<br>    PTYPE_DEBUG = 9,<br>    PTYPE_LUA = 10,<br>    PTYPE_SNAX = 11,<br>}<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>pack：发送消息时，对消息进行打包的函数</span><br><span class="line"><span class="bullet">* </span>unpack：接收到消息时，先通过unpack函数，对消息进行解包后，再传给dispatch函数，最后实现消息回调</span><br><span class="line"><span class="bullet">* </span>dispatch：消息队列里的指定类型的消息，最终会传到指定类型的dispatch函数来，这个函数一般是用户自己指定  </span><br><span class="line"></span><br><span class="line">现在通过启动一个example服务来举例说明，example服务的定义如下所示：</span><br></pre></td></tr></table></figure></p>
<p>– example.lua<br>local skynet = require “skynet”</p>
<p>skynet.register_protocol {<br>    name = “text”,<br>    id = skynet.PTYPE<em>TEXT,<br>    unpack = function (msg, sz)<br>        return skynet.tostring(msg, sz)<br>    end,<br>    dispatch = function (</em>, _, type, arg)<br>        skynet.error(arg)<br>    end<br>}</p>
<p>local CMD = {}</p>
<p>function CMD.do_something(…)<br>    – TODO<br>end</p>
<p>skynet.dispatch(“lua”, function(<em>,</em>, command, …)<br>    local f = CMD[command]<br>    skynet.ret(skynet.pack(f(…)))<br>end)</p>
<p>skynet.start(function()<br>    – TODO<br>end)</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动一个example服务，意味着loader脚本，最终执行的那个脚本就是example.<span class="keyword">lua</span>这个脚本，在执行这个脚本的过程中，首先和其他所有的<span class="keyword">lua</span>服务一样，这个example服务需要调用skynet.<span class="keyword">lua</span>里的api，因此，需要require一下skynet.<span class="keyword">lua</span>这个脚本，而在require的过程中，就已经注册了几个回调消息处理协议：</span><br></pre></td></tr></table></figure>
<p>– skynet.lua</p>
<p>…</p>
<p>—– register protocol<br>do<br>    local REG = skynet.register_protocol</p>
<pre><code>REG {
    name = <span class="string">"lua"</span>,
    id = skynet.PTYPE_LUA,
    pack = skynet.pack,
    unpack = skynet.unpack,
}

REG {
    name = <span class="string">"response"</span>,
    id = skynet.PTYPE_RESPONSE,
}

REG {
    name = <span class="string">"error"</span>,
    id = skynet.PTYPE_ERROR,
    unpack = <span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...) return</span> <span class="rest_arg">... end</span>,
    dispatch = _error_dispatch,
}</span></span>
</code></pre><p>end</p>
<p>…</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里事先注册了<span class="keyword">lua</span>类型，response类型和error类型的消息处理协议，也就是说，一个<span class="keyword">lua</span>服务至少保证<span class="keyword">lua</span>类型、response类型和error类型默认有消息处理协议，而注册函数的流程就是将这个消息处理协议的结构存入proto表中，当一个<span class="keyword">lua</span>服务接收到消息时，则会根据其消息类型，在proto表中找到对应的处理协议以后，调用该协议的unpack函数，将参数解包以后，再传给该协议的dispatch函数，最后达到驱动<span class="keyword">lua</span>服务的目的：</span><br></pre></td></tr></table></figure>
<p>– skynet.lua<br>function skynet.register_protocol(class)<br>    local name = class.name<br>    local id = class.id<br>    assert(proto[name] == nil)<br>    assert(type(name) == “string” and type(id) == “number” and id &gt;=0 and id &lt;=255)<br>    proto[name] = class<br>    proto[id] = class<br>end<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在回到我们的example脚本，它注册了一个<span class="keyword">text</span>类消息处理协议，然后为lua协议注册了一个回调函数，我们注意到，在skynet.lua这个脚本中，虽然又在proto表中注册lua类型的处理函数，但是没有定义该类型的回调函数<span class="built_in">dispatch</span>，这个<span class="built_in">dispatch</span>函数，需要用户自己定义，一般使用skynet.<span class="built_in">dispatch</span>来完成</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function skynet.dispatch(typename, func)<br>    local p = proto[typename]<br>    if func then<br>        local ret = p.dispatch<br>        p.dispatch = func<br>        return ret<br>    else<br>        return p and p.dispatch<br>    end<br>end<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exmaple脚本为<span class="keyword">lua</span>类型消息处理协议，注册了一个<span class="keyword">lua</span>层消息回调函数skynet.dispatch_message，后面example服务接收到的<span class="keyword">lua</span>类型消息，都会被传到这个函数内  </span><br><span class="line">最后，example脚本执行了skynet.start函数，完成启动一个<span class="keyword">lua</span>服务的最后工作</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function skynet.start(start_func)<br>    c.callback(skynet.dispatch_message)<br>    skynet.timeout(0, function()<br>        skynet.init_service(start_func)<br>    end)<br>end<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个函数，首先<span class="keyword">lua</span>服务注册了一个<span class="keyword">lua</span>层的消息回调函数，前面已经讨论过，一个<span class="keyword">c</span>服务在消费次级消息队列的消息时，最终会调用callback函数，而这里做的工作则是，通过这个<span class="keyword">c</span>层的callback函数，再转调<span class="keyword">lua</span>层消息回调函数skynet.dispatch_message</span><br></pre></td></tr></table></figure></p>
<p>// lua-skynet.c<br>static int<br>_cb(struct skynet_context <em> context, void </em> ud, int type, int session, uint32_t source, const void <em> msg, size_t sz) {<br>    lua_State </em>L = ud;<br>    int trace = 1;<br>    int r;<br>    int top = lua_gettop(L);<br>    if (top == 0) {<br>        lua_pushcfunction(L, traceback);<br>        lua_rawgetp(L, LUA_REGISTRYINDEX, _cb);<br>    } else {<br>        assert(top == 2);<br>    }<br>    lua_pushvalue(L,2);</p>
<pre><code>lua_pushinteger(<span class="keyword">L</span>, <span class="keyword">type</span>);
lua_pushlightuserdata(<span class="keyword">L</span>, (void *)msg);
lua_pushinteger(<span class="keyword">L</span>,sz);
lua_pushinteger(<span class="keyword">L</span>, session);
lua_pushinteger(<span class="keyword">L</span>, source);

r = lua_pcall(<span class="keyword">L</span>, 5, 0 , trace);

...

<span class="keyword">return</span> 0;
</code></pre><p>}</p>
<p>static int<br>_callback(lua_State <em>L) {<br>    struct skynet_context </em> context = lua_touserdata(L, lua_upvalueindex(1));<br>    int forward = lua_toboolean(L, 2);<br>    luaL_checktype(L,1,LUA_TFUNCTION);<br>    lua_settop(L,1);<br>    lua_rawsetp(L, LUA_REGISTRYINDEX, _cb);</p>
<pre><code>lu<span class="built_in">a_rawgeti</span>(L, LU<span class="built_in">A_REGISTRYINDEX</span>, LU<span class="built_in">A_RIDX</span>_MAINTHREAD)<span class="comment">;</span>
lu<span class="built_in">a_State</span> *gL = lu<span class="built_in">a_tothread</span>(L,-<span class="number">1</span>)<span class="comment">;</span>

<span class="keyword">if</span> (forward) {
    skynet_callback(context, gL, forward_cb)<span class="comment">;</span>
} <span class="keyword">else</span> {
    skynet_callback(context, gL, _cb)<span class="comment">;</span>
}

<span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span>
</code></pre><p>}<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里将snlua这个skynet_context的callback函数赋值为_cb，而_cb最终又会通过lua_State转调<span class="keyword">lua</span>层的skynet.dispatch_message函数，也就是说，发送给snlua服务的消息，最终都是交给<span class="keyword">lua</span>层去处理的  </span><br><span class="line">在完成<span class="keyword">lua</span>层callback函数的注册以后，接下来就是执行<span class="keyword">lua</span>服务的启动函数（也就是skynet.start函数的第二个参数）</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>local function init_template(start)<br>    init_all()<br>    init_func = {}<br>    start()<br>    init_all()<br>end</p>
<p>function skynet.pcall(start)<br>    return xpcall(init_template, debug.traceback, start)<br>end</p>
<p>function skynet.init_service(start)<br>    local ok, err = skynet.pcall(start)<br>    if not ok then<br>        skynet.error(“init service failed: “ .. tostring(err))<br>        skynet.send(“.launcher”,”lua”, “ERROR”)<br>        skynet.exit()<br>    else<br>        skynet.send(“.launcher”,”lua”, “LAUNCHOK”)<br>    end<br>end<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">这里并没有立即执行这个<span class="operator"><span class="keyword">start</span>函数，而是故意放在了下一帧进行。到了目前这一步，整个example服务就被启动起来了，虽然他并没有执行什么逻辑，但是却展现了一个lua层服务完整的创建流程，下一节将介绍lua层消息处理机制。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#### lua层消息处理机制</span><br><span class="line"><span class="number">1.</span> 协程的概念  </span><br><span class="line">在讨论lua层的消息处理机制之前，首先要了解一个概念，协程。协程可以视为程序的执行单位，和线程不同，线程是抢占式的，多条线程是并行时运行的，而协程则不是，协程是协同式的，比如有三个协程按顺序先后创建coA、coB、coC，那么在没有任意一条协程主动挂起（yield）的情况下，执行顺序则是coA执行完，在执行coB，然后再执行coC。也就是说，除非有协程主动要求挂起，否则必须等当前协程执行完，再去执行下面一个创建的协程。比如说，coA执行完，接着就是执行coB，此时coB挂起，那么直接执行coC，coC执行完以后，如果coB被唤醒了，则接着上次开始阻塞的部分继续执行余下的逻辑。维基百科对协程的定义如下：  </span><br><span class="line">&gt; 引证来源：https://en.wikipedia.org/wiki/Thread_(computing) 【Processes, kernel threads, <span class="keyword">user</span> threads, <span class="keyword">and</span> fibers】这一节  </span><br><span class="line">&gt; Fibers <span class="keyword">are</span> an even lighter unit <span class="keyword">of</span> scheduling which <span class="keyword">are</span> cooperatively scheduled: a running fiber must explicitly <span class="string">"yield"</span> <span class="keyword">to</span> <span class="keyword">allow</span> another fiber <span class="keyword">to</span> run, which makes their implementation much easier <span class="keyword">than</span> kernel <span class="keyword">or</span> <span class="keyword">user</span> threads. A fiber can be scheduled <span class="keyword">to</span> run <span class="keyword">in</span> <span class="keyword">any</span> <span class="keyword">thread</span> <span class="keyword">in</span> the same process. This permits applications <span class="keyword">to</span> gain <span class="keyword">performance</span> improvements <span class="keyword">by</span> managing scheduling themselves, instead <span class="keyword">of</span> relying <span class="keyword">on</span> the kernel scheduler (which may <span class="keyword">not</span> be tuned <span class="keyword">for</span> the application). <span class="keyword">Parallel</span> programming environments such <span class="keyword">as</span> OpenMP typically implement their tasks <span class="keyword">through</span> fibers. Closely related <span class="keyword">to</span> fibers <span class="keyword">are</span> coroutines, <span class="keyword">with</span> the distinction being that coroutines <span class="keyword">are</span> a <span class="keyword">language</span>-<span class="keyword">level</span> construct, <span class="keyword">while</span> fibers <span class="keyword">are</span> a <span class="keyword">system</span>-<span class="keyword">level</span> construct.  </span><br><span class="line"></span><br><span class="line">如上所示，协程和纤程十分相似（纤程是线程下的执行单位），区别在于，纤程是操作系统实现的，而协程是语言本身提供。  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 协程的使用  </span><br><span class="line">这里引用一篇文档加以说明：  </span><br><span class="line">&gt; 引证来源：<span class="keyword">http</span>://cloudwu.github.io/lua53doc/<span class="keyword">manual</span>.html#<span class="number">2.6</span>  </span><br><span class="line">&gt; Lua 支持协程，也叫 协同式多线程。 一个协程在 Lua 中代表了一段独立的执行线程。 然而，与多线程系统中的线程的区别在于， 协程仅在显式调用一个让出（yield）函数时才挂起当前的执行。</span><br><span class="line"></span><br><span class="line">&gt; 调用函数 coroutine.<span class="keyword">create</span> 可创建一个协程。 其唯一的参数是该协程的主函数。 <span class="keyword">create</span> 函数只负责新建一个协程并返回其句柄 （一个 <span class="keyword">thread</span> 类型的对象）； 而不会启动该协程。</span><br><span class="line"></span><br><span class="line">&gt; 调用 coroutine.<span class="keyword">resume</span> 函数执行一个协程。 第一次调用 coroutine.<span class="keyword">resume</span> 时，第一个参数应传入 coroutine.<span class="keyword">create</span> 返回的线程对象，然后协程从其主函数的第一行开始执行。 传递给 coroutine.<span class="keyword">resume</span> 的其他参数将作为协程主函数的参数传入。 协程启动之后，将一直运行到它终止或 让出。</span><br><span class="line"></span><br><span class="line">&gt; 协程的运行可能被两种方式终止： 正常途径是主函数返回 （显式返回或运行完最后一条指令）； 非正常途径是发生了一个未被捕获的错误。 对于正常结束， coroutine.<span class="keyword">resume</span> 将返回 <span class="literal">true</span>， 并接上协程主函数的返回值。 当错误发生时， coroutine.<span class="keyword">resume</span> 将返回 <span class="literal">false</span> 与错误消息。</span><br><span class="line"></span><br><span class="line">&gt; 通过调用 coroutine.yield 使协程暂停执行，让出执行权。 协程让出时，对应的最近 coroutine.<span class="keyword">resume</span> 函数会立刻返回，即使该让出操作发生在内嵌函数调用中 （即不在主函数，但在主函数直接或间接调用的函数内部）。 在协程让出的情况下， coroutine.<span class="keyword">resume</span> 也会返回 <span class="literal">true</span>， 并加上传给 coroutine.yield 的参数。 当下次重启同一个协程时， 协程会接着从让出点继续执行。 此时，此前让出点处对 coroutine.yield 的调用 会返回，返回值为传给 coroutine.<span class="keyword">resume</span> 的第一个参数之外的其他参数。</span><br><span class="line"></span><br><span class="line">&gt; 与 coroutine.<span class="keyword">create</span> 类似， coroutine.wrap 函数也会创建一个协程。 不同之处在于，它不返回协程本身，而是返回一个函数。 调用这个函数将启动该协程。 传递给该函数的任何参数均当作 coroutine.<span class="keyword">resume</span> 的额外参数。 coroutine.wrap 返回 coroutine.<span class="keyword">resume</span> 的所有返回值，除了第一个返回值（布尔型的错误码）。 和 coroutine.<span class="keyword">resume</span> 不同， coroutine.wrap 不会捕获错误； 而是将任何错误都传播给调用者。</span><br><span class="line"></span><br><span class="line">&gt; 下面的代码展示了一个协程工作的范例：</span><br><span class="line"></span><br><span class="line">     <span class="keyword">function</span> foo (a)</span><br><span class="line">       print(<span class="string">"foo"</span>, a)</span><br><span class="line">       <span class="keyword">return</span> coroutine.yield(<span class="number">2</span>*a)</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">     co = coroutine.<span class="keyword">create</span>(<span class="keyword">function</span> (a,b)</span><br><span class="line">           print(<span class="string">"co-body"</span>, a, b)</span><br><span class="line">           <span class="keyword">local</span> r = foo(a+<span class="number">1</span>)</span><br><span class="line">           print(<span class="string">"co-body"</span>, r)</span><br><span class="line">           <span class="keyword">local</span> r, s = coroutine.yield(a+b, a-b)</span><br><span class="line">           print(<span class="string">"co-body"</span>, r, s)</span><br><span class="line">           <span class="keyword">return</span> b, <span class="string">"end"</span></span><br><span class="line">     <span class="keyword">end</span>)</span><br><span class="line">     </span><br><span class="line">     print(<span class="string">"main"</span>, coroutine.<span class="keyword">resume</span>(co, <span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">     print(<span class="string">"main"</span>, coroutine.<span class="keyword">resume</span>(co, <span class="string">"r"</span>))</span><br><span class="line">     print(<span class="string">"main"</span>, coroutine.<span class="keyword">resume</span>(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</span><br><span class="line">     print(<span class="string">"main"</span>, coroutine.<span class="keyword">resume</span>(co, <span class="string">"x"</span>, <span class="string">"y"</span>))</span><br><span class="line">&gt; 当你运行它，将产生下列输出：</span><br><span class="line"></span><br><span class="line">     co-<span class="keyword">body</span> <span class="number">1</span>       <span class="number">10</span></span><br><span class="line">     foo     <span class="number">2</span></span><br><span class="line">     <span class="keyword">main</span>    <span class="literal">true</span>    <span class="number">4</span></span><br><span class="line">     co-<span class="keyword">body</span> r</span><br><span class="line">     <span class="keyword">main</span>    <span class="literal">true</span>    <span class="number">11</span>      -<span class="number">9</span></span><br><span class="line">     co-<span class="keyword">body</span> x       y</span><br><span class="line">     <span class="keyword">main</span>    <span class="literal">true</span>    <span class="number">10</span>      <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">main</span>    <span class="literal">false</span>   cannot <span class="keyword">resume</span> dead coroutine</span><br><span class="line">&gt; 你也可以通过 <span class="keyword">C</span> API 来创建及操作协程： 参见函数 lua_newthread， lua_resume， 以及 lua_yield。  </span><br><span class="line"></span><br><span class="line">这里对lua协程的代码使用，做了充分的说明，对我们理解lua层消息派发十分有帮助</span><br><span class="line"><span class="number">3.</span> skynet消息处理机制  </span><br><span class="line">在前文，我们已经说明了，一个lua服务在接收消息时，最终会传给lua层的消息回调函数skynet.dispatch_message</span></span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function skynet.dispatch_message(…)<br>    local succ, err = pcall(raw_dispatch_message,…)<br>    while true do<br>        local key,co = next(fork_queue)<br>        if co == nil then<br>            break<br>        end<br>        fork_queue[key] = nil<br>        local fork_succ, fork_err = pcall(suspend,co,coroutine.resume(co))<br>        if not fork_succ then<br>            if succ then<br>                succ = false<br>                err = tostring(fork_err)<br>            else<br>                err = tostring(err) .. “\n” .. tostring(fork_err)<br>            end<br>        end<br>    end<br>    assert(succ, tostring(err))<br>end<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息处理函数，只做两件事情，一件是消费当前消息，另一件则是按顺序执行之前通过调用<span class="tag">skynet</span><span class="class">.fork</span>创建的协程，这里我么只关注处理当前消息的情况<span class="tag">raw_dispatch_message</span></span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>local function raw_dispatch_message(prototype, msg, sz, session, source, …)<br>    – skynet.PTYPE_RESPONSE = 1, read skynet.h<br>    if prototype == 1 then<br>        … – 暂不讨论，直接忽略<br>    else<br>        local p = proto[prototype]    – 找到与消息类型对应的解析协议<br>        if p == nil then<br>            if session ~= 0 then<br>                c.send(source, skynet.PTYPE_ERROR, session, “”)<br>            else<br>                unknown_request(session, source, msg, sz, prototype)<br>            end<br>            return<br>        end<br>        local f = p.dispatch  – 获取消息处理函数，可以视为该类协议的消息回调函数<br>        if f then<br>            local ref = watching_service[source]<br>            if ref then<br>                watching_service[source] = ref + 1<br>            else<br>                watching_service[source] = 1<br>            end<br>            local co = co_create(f)   – 如果协程池内有空闲的协程，则直接返回，否则创建一个新的协程，该协程用于执行该类协议的消息处理函数dispatch<br>            session_coroutine_id[co] = session<br>            session_coroutine_address[co] = source<br>            suspend(co, coroutine.resume(co, session,source, p.unpack(msg,sz, …)))  – 启动并执行协程，将结果返回给suspend<br>        else<br>            unknown_request(session, source, msg, sz, proto[prototype].name)<br>        end<br>    end<br>end<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消息处理的分为两种情况，一种是其他服务<span class="built_in">send</span>过来的消息，还有一种就是自己发起同步rpc调用（调用call）后，获得的返回结果（返回消息的类型是PTYPE_RESPONSE）。关于call的情况，后面会详细讨论，现在只讨论如何处理其他服务<span class="built_in">send</span>过来的消息。  </span><br><span class="line">整个执行的流程如下所示：  </span><br><span class="line">* 根据消息的类型，找到对应的先前注册好的消息解析协议</span><br><span class="line">* 获取一个协程（如果协程池中有空闲的协程，则直接获取，否则重新创建一个），并让该协程执行消息处理协议的回调函数<span class="built_in">dispatch</span></span><br><span class="line">* 启动并执行协程，将协程执行的结果返回给suspend函数，返回结果，就是一个coroutine挂起的原因，这个suspend函数，就是针对coroutine挂起的不同原因，做专门的处理</span><br><span class="line"></span><br><span class="line">这里对协程的复用，做一些小小的说明，创建协程的函数，非常有意思，为了进一步提高性能，skynet对协程做了缓存，也就是说，一个协程在使用完以后，并不是让他结束掉，而是把上一次使用的<span class="built_in">dispatch</span>函数清掉，并且挂起协程，放入一个协程池中，供下一次调用。下次使用时，他将执行新的<span class="built_in">dispatch</span>函数，只有当协程池中没有协程时，才会去创建新协程，如此循环往复</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>local function co_create(f)<br>    local co = table.remove(coroutine_pool)<br>    if co == nil then  – 协程池中，再也找不到可以用的协程时，将重新创建一个<br>        co = coroutine.create(function(…)<br>            f(…)  – 执行回调函数，创建协程时，并不会立即执行，只有调用coroutine.resume时，才会执行内部逻辑，这行代码，只有在首次创建时会被调用</p>
<pre><code>        <span class="comment">-- 回调函数执行完，协程本次调用的使命就完成了，但是为了实现复用，这里不能让协程退出，而是将</span>
        <span class="comment">-- upvalue回调函数f赋值为空，再放入协程缓存池中，并且挂起，以便下次使用</span>
        while true <span class="operator"><span class="keyword">do</span>
            <span class="keyword">f</span> = nil
            coroutine_pool[#coroutine_pool+<span class="number">1</span>] = co

            <span class="keyword">f</span> = coroutine_yield <span class="string">"EXIT"</span>  <span class="comment">-- （1）</span>
            <span class="keyword">f</span>(coroutine_yield())  <span class="comment">-- （2）</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>)
<span class="keyword">else</span>
    coroutine.<span class="keyword">resume</span>(co, <span class="keyword">f</span>)  <span class="comment">-- 唤醒第（1）处代码，并将新的回调函数，赋值给（1）处的upvalue f函数，此时在第（2）个yield处挂起</span>
<span class="keyword">end</span>
<span class="keyword">return</span> co</span>
</code></pre><p>end</p>
<p>local function raw_dispatch_message(prototype, msg, sz, session, source, …)<br>    …<br>    – 如果是创建后第一次使用这个coroutine，这里的coroutine.resume函数，将会唤醒该coroutine，并将第二个至最后一个参数，传给运行的函数<br>    – 如果是一个复用中的协程，那么这里的coroutine.resume会将第二个至最后一个参数，通过第（2）处的coroutine_yield返回给消息回调函数<br>    suspend(co, coroutine.resume(co, session,source, p.unpack(msg,sz, …)))<br>    …<br>end<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的逻辑在完成回调函数调用后，会对协程进行回收，它会将回调函数清掉，并且将当前协程写入协程缓存列表中，然后挂起协程，挂起类型为“<span class="keyword">EXIT</span>”，如上面的代码所示，对挂起类型进行处理的函数是suspend函数，当一个协程结束时，会进行如下操作</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function suspend(co, result, command, param, size)<br>…<br>    elseif command == “EXIT” then<br>        – coroutine exit<br>        local address = session_coroutine_address[co]<br>        release_watching(address)<br>        session_coroutine_id[co] = nil<br>        session_coroutine_address[co] = nil<br>        session_response[co] = nil<br>…<br>end</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实这里是将与本协程关联的数据清空，包括向本服务发送消息的服务的地址，session，以及本服务对请求服务返回消息的确认信息。在lua层处理一条消息，本质上是在一个协程里进行的，因此要以协程句柄作为key，保存这些变量。协程每次暂停，都需要使用或处理这些数据，并告知当前协程的状态，以及要根据不同的状态做出相应的处理逻辑，比如当一个协程使用完毕时，就会挂起，并返回“EXIT”类型，意味着协程已经和之前的消息无关系了，需要清空与本协程关联的所有消息相关的信息，以便下一条消息使用。  </span><br><span class="line">协程发起一次同步RPC调用（挂起状态类型为“<span class="operator"><span class="keyword">CALL</span>”），或者投入睡眠时（挂起状态类型为“<span class="keyword">SLEEP</span>”），也会使自己挂起，此时要为当前的协程分配一个唯一的<span class="keyword">session</span>变量，并且以<span class="keyword">session</span>为<span class="keyword">key</span>，协程地址为<span class="keyword">value</span>存入一个<span class="keyword">table</span>表中，目的是，当对方返回结果，或者定时器到达时间timer线程向本服务发送一个唤醒原来协程的消息时，能够通过<span class="keyword">session</span>找到对应的协程，并将其唤醒，从之前挂起的地方继续执行下去。  </span><br><span class="line">当一个服务向本服务发起一次<span class="keyword">call</span>调用时，本服务需要返回一个结果变量给请求者，此时也需要将本协程挂起，向请求者返回结果时，需要调用如下接口</span></span><br></pre></td></tr></table></figure>
<p>– skynet.lua<br>function skynet.ret(msg, sz)<br>    msg = msg or “”<br>    return coroutine_yield(“RETURN”, msg, sz) – （1）<br>end</p>
<p>function suspend(co, result, command, param, size)<br>…<br>    elseif command == “RETURN” then<br>        local co_session = session_coroutine_id[co]<br>        local co_address = session_coroutine_address[co]<br>        if param == nil or session_response[co] then<br>            error(debug.traceback(co))<br>        end<br>        session_response[co] = true<br>        local ret<br>        if not dead_service[co_address] then<br>            ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, param, size) ~= nil<br>            if not ret then<br>                – If the package is too large, returns nil. so we should report error back<br>                c.send(co_address, skynet.PTYPE_ERROR, co_session, “”)<br>            end<br>        elseif size ~= nil then<br>            c.trash(param, size)<br>            ret = false<br>        end<br>        return suspend(co, coroutine.resume(co, ret)) – 重新唤醒（1）处，此时skynet.ret返回<br>…<br>end<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在调用skynet.ret以后，调用该接口的协程就会挂起，此时挂起的状态类型是“RETURN”，这里挂起的目的是，等待返回消息的逻辑处理完，再接着执行协程挂起处后面的逻辑。suspend里所做的处理，也就是，将消息插入目的服务的次级消息队列中，然后再唤醒已经挂起的协程。  </span><br><span class="line"></span><br><span class="line">4. 对其他服务的<span class="operator"><span class="keyword">call</span>访问  </span><br><span class="line">一个服务，向另一个服务发起同步rpc调用，首先要挂起当前协程，然后是将目的服务发送一个消息，并且在本地记录一个唯一的<span class="keyword">session</span>值，并以其为<span class="keyword">key</span>，以挂起的协程地址为<span class="keyword">value</span>存入一个<span class="keyword">table</span>中，当目标服务返回结果时，根据这个<span class="keyword">session</span>找回对应的协程，并且调用<span class="keyword">resume</span>函数唤醒他。</span></span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>local function yield_call(service, session)<br>    watching_session[session] = service<br>    local succ, msg, sz = coroutine_yield(“CALL”, session)<br>    watching_session[session] = nil<br>    if not succ then<br>        error “call failed”<br>    end<br>    return msg,sz<br>end</p>
<p>function skynet.call(addr, typename, …)<br>    local p = proto[typename]<br>    local session = c.send(addr, p.id , nil , p.pack(…))<br>    if session == nil then<br>        error(“call to invalid address “ .. skynet.address(addr))<br>    end<br>    return p.unpack(yield_call(addr, session))<br>end</p>
<p>function suspend(co, result, command, param, size)<br>…<br>    if command == “CALL” then<br>        session_id_coroutine[param] = co<br>…<br>end</p>
<p>local function raw_dispatch_message(prototype, msg, sz, session, source, …)<br>    – skynet.PTYPE_RESPONSE = 1, read skynet.h<br>    if prototype == 1 then<br>        local co = session_id_coroutine[session]<br>        if co == “BREAK” then<br>            session_id_coroutine[session] = nil<br>        elseif co == nil then<br>            unknown_response(session, source, msg, sz)<br>        else<br>            session_id_coroutine[session] = nil<br>            suspend(co, coroutine.resume(co, true, msg, sz))<br>        end<br>    else<br>    …<br>    end<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上面一段逻辑的流程如下所示：  </span><br><span class="line"><span class="keyword">*</span> 发起一个同步rpc调用，向目标服务的次级消息队列插入一个消息</span><br><span class="line"><span class="keyword">*</span> 挂起当前协程，yield_call里的coroutine_yield(<span class="string">"CALL"</span>, session)使得当前协程挂起，并在此时suspend执行记录session为key，协程地址为value，将其写入一个table session_id_coroutine中，此时协程等待对方返回消息</span><br><span class="line"><span class="keyword">*</span> 当目标服务返回结果时，先根据session找到先前挂起的协程地址，然后通过resume函数唤醒他，此时call返回结果，一次同步rpc调用就结束了。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### timer的运作机制</span></span><br><span class="line">我们使用定时器的两种情况，一种是设置一个定时器，让某个函数在t秒后执行；还有一种则是，在执行某个函数的过程中，暂停t秒后继续执行。  </span><br><span class="line">第一种情况，我们使用skynet.timeout来执行：</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function skynet.timeout(ti, func)<br>    local session = c.intcommand(“TIMEOUT”,ti)<br>    assert(session)<br>    local co = co_create(func)<br>    assert(session_id_coroutine[session] == nil)<br>    session_id_coroutine[session] = co<br>end<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里，首先向定时器注册了一个事件，这个事件的信息包含服务地址、多少秒后触发定时事件以及一个session变量；然后为执行函数创建一个协程，协程创建后默认不执行，因此目前的<span class="function"><span class="keyword">func</span>相当于冻结状态，最后<span class="title">lua</span>层会以<span class="title">session</span>为<span class="title">key</span>，协程地址为<span class="title">value</span>存入一个<span class="title">table</span>表中。当该事件的触发时间到的时候，<span class="title">timer</span>线程会取出时间数据，向事件所属的地址发送一条<span class="title">RESPONSE</span>类型的消息</span></span><br></pre></td></tr></table></figure></p>
<p>// skynet_timer.c<br>static inline void<br>dispatch_list(struct timer_node <em>current) {<br>    do {<br>        struct timer_event </em> event = (struct timer_event *)(current+1);<br>        struct skynet_message message;<br>        message.source = 0;<br>        message.session = event-&gt;session;<br>        message.data = NULL;<br>        message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</p>
<pre><code>    skynet_context_push(event-&gt;handle, &amp;message)<span class="comment">;</span>

    struct timer_node * temp = current<span class="comment">;</span>
    current=current-&gt;next<span class="comment">;</span>
    skynet_free(temp)<span class="comment">;    </span>
} while (current)<span class="comment">;</span>
</code></pre><p>}<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务收到这个消息以后，会根据session的值，找回协程地址，并调用resume函数，唤醒这个协程，这样就完成了t秒后执行某个函数的功能。  </span><br><span class="line">第二种情况，我们使用skynet.<span class="built_in">sleep</span>来执行</span><br></pre></td></tr></table></figure></p>
<p>– skynet.lua<br>function skynet.sleep(ti)<br>    local session = c.intcommand(“TIMEOUT”,ti)<br>    assert(session)<br>    local succ, ret = coroutine_yield(“SLEEP”, session)<br>    sleep_session[coroutine.running()] = nil<br>    if succ then<br>        return<br>    end<br>    if ret == “BREAK” then<br>        return “BREAK”<br>    else<br>        error(ret)<br>    end<br>end<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一个协程内的函数，在执行的过程中，调用了<span class="keyword">sleep</span>函数以后，此时首先会向定时器注册一个事件，这个时间包含了服务地址、睡眠时间ti和一个session变量，然后就对当前协程执行挂起操作，挂起类型为<span class="keyword">SLEEP</span>，此时会触发对suspend函数的调用，前面已经讨论过，suspend函数对<span class="keyword">SLEEP</span>这种挂起类型的处理是，以session为key，再以协程地址为value存入一个<span class="keyword">table</span>中（详见 lua层消息处理机制 一节）。在ti秒以后，<span class="keyword">timer</span>线程触发定时事件，并向服务发送一个RESPONSE类型的消息，服务收到消息以后会调用resume唤醒该协程，从而使该协程继续执行后面的逻辑。  </span><br><span class="line">本节讨论了定时器最常见的两种使用情况，并且讨论了<span class="keyword">timer</span>线程如何和worker线程内的服务进行交互，本节为了突出问题关键，并未对<span class="keyword">timer</span>内部的运作细节进行一一讨论，但是这些事没有必要的，我们只要知道<span class="keyword">timer</span>事件如何添加，<span class="keyword">timer</span>何时会通知服务，如何通知即可，无需在一些复杂的细节里耗费太多的时间和精力。</span><br><span class="line"></span><br><span class="line">#### 网络层运作机制</span><br><span class="line">对于网络层，本质上是对socket线程的运作流程进行讨论，本节的主要目标是弄清以下几个问题：  </span><br><span class="line"><span class="comment">* skynet网络层的初始化流程是怎样的？</span></span><br><span class="line"><span class="comment">* skynet网络层是如何绑定和监听一个端口的？</span></span><br><span class="line"><span class="comment">* skynet网络层，建立一个连接的流程是怎样的？</span></span><br><span class="line"><span class="comment">* 客户端发送的数据包，是怎样转发到指定的服务上的？</span></span><br><span class="line"><span class="comment">* 服务端不同服务的数据包，发送到客户端的流程是怎样的？</span></span><br><span class="line"></span><br><span class="line">捋清了上面几点，基本上就捋清了skynet网络层的运作流程，这里不讨论所有的通信细节，只是对主流程进行讨论，虽然skynet包含epoll模型和kqueue，这里只对epoll进行讨论。  </span><br><span class="line"></span><br><span class="line">1. skynet网络层基本数据结构  </span><br><span class="line">    在开始讨论具体的流程之前，首先我们要讨论一下socket部分的主要数据结构</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="comment">// socket_server.c</span>
<span class="keyword">struct</span> socket {
    uintptr_t opaque;       <span class="comment">// 与本socket关联的服务地址，socket接收到的消息，最后将会传送到这个服务商</span>
    <span class="keyword">struct</span> wb_list high;    <span class="comment">// 高优先级发送队列</span>
    <span class="keyword">struct</span> wb_list low;     <span class="comment">// 低优先级发送队列</span>
    int64_t wb_size;        <span class="comment">// 发送字节大小</span>
    <span class="keyword">int</span> fd;                 <span class="comment">// socket文件描述符</span>
    <span class="keyword">int</span> id;                 <span class="comment">// 位于socket_server的slot列表中的位置</span>
    uint16_t protocol;      <span class="comment">// 使用的协议tcp or udp </span>
    uint16_t type;          <span class="comment">// epoll事件触发时，会根据type来选择处理事件的逻辑</span>
    <span class="keyword">union</span> {
        <span class="keyword">int</span> size;
        uint8_t udp_address[UDP_ADDRESS_SIZE];
    } p;
};

<span class="keyword">struct</span> socket_server {
    <span class="keyword">int</span> recvctrl_fd;        <span class="comment">// 接收管道消息的文件描述</span>
    <span class="keyword">int</span> sendctrl_fd;        <span class="comment">// 发送管道消息的文件描述</span>
    <span class="keyword">int</span> checkctrl;          <span class="comment">// 判断是否有其他线程通过管道，向socket线程发送消息的标记变量</span>
    poll_fd event_fd;       <span class="comment">// epoll实例id</span>
    <span class="keyword">int</span> alloc_id;           <span class="comment">// 已经分配的socket slot列表id</span>
    <span class="keyword">int</span> event_n;            <span class="comment">// 标记本次epoll事件的数量</span>
    <span class="keyword">int</span> event_index;        <span class="comment">// 下一个未处理的epoll事件索引</span>
    <span class="keyword">struct</span> socket_object_interface soi;
    <span class="keyword">struct</span> event ev[MAX_EVENT]; <span class="comment">// epoll事件列表</span>
    <span class="keyword">struct</span> socket slot[MAX_SOCKET];  <span class="comment">// socket 列表</span>
    <span class="built_in">char</span> buffer[MAX_INFO];  <span class="comment">// 地址信息转成字符串以后，存在这里</span>
    uint8_t udpbuffer[MAX_UDP_PACKAGE];
    fd_set rfds;
};
&lt;!--￼<span class="number">35</span>--&gt;

<span class="comment">// socket_server.c</span>
<span class="keyword">static</span> <span class="keyword">struct</span> socket *
new_fd(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">int</span> id, <span class="keyword">int</span> fd, <span class="keyword">int</span> protocol, uintptr_t opaque, <span class="built_in">bool</span> add) {
    <span class="keyword">struct</span> socket * s = &amp;ss-&gt;slot[HASH_ID(id)];
    <span class="keyword">assert</span>(s-&gt;type == SOCKET_TYPE_RESERVE);

    <span class="keyword">if</span> (add) {
        <span class="keyword">if</span> (sp_add(ss-&gt;event_fd, fd, s)) {
            s-&gt;type = SOCKET_TYPE_INVALID;
            <span class="keyword">return</span> NULL;
        }
    }

    s-&gt;id = id;
    s-&gt;fd = fd;
    s-&gt;protocol = protocol;
    s-&gt;p.size = MIN_READ_BUFFER;
    s-&gt;opaque = opaque;
    s-&gt;wb_size = <span class="number">0</span>;
    check_wb_list(&amp;s-&gt;high);
    check_wb_list(&amp;s-&gt;low);
    <span class="keyword">return</span> s;
}

<span class="comment">// socket_epoll.h</span>
<span class="keyword">static</span> <span class="keyword">int</span> 
sp_add(<span class="keyword">int</span> efd, <span class="keyword">int</span> sock, <span class="keyword">void</span> *ud) {
    <span class="keyword">struct</span> epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.ptr = ud;
    <span class="keyword">if</span> (epoll_ctl(efd, EPOLL_CTL_ADD, sock, &amp;ev) == -<span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
&lt;!--￼<span class="number">36</span>--&gt;

<span class="comment">// return type</span>
<span class="keyword">int</span> 
socket_server_poll(<span class="keyword">struct</span> socket_server *ss, <span class="keyword">struct</span> socket_message * result, <span class="keyword">int</span> * more) {
    <span class="keyword">for</span> (;;) {
        ...
        <span class="keyword">if</span> (ss-&gt;event_index == ss-&gt;event_n) {
            ss-&gt;event_n = sp_wait(ss-&gt;event_fd, ss-&gt;ev, MAX_EVENT);
            ss-&gt;checkctrl = <span class="number">1</span>;
            <span class="keyword">if</span> (more) {
                *more = <span class="number">0</span>;
            }
            ss-&gt;event_index = <span class="number">0</span>;
            <span class="keyword">if</span> (ss-&gt;event_n &lt;= <span class="number">0</span>) {
                ss-&gt;event_n = <span class="number">0</span>;
                <span class="keyword">return</span> -<span class="number">1</span>;
            }
        }
        <span class="keyword">struct</span> event *e = &amp;ss-&gt;ev[ss-&gt;event_index++];
        <span class="keyword">struct</span> socket *s = e-&gt;s;
        <span class="keyword">if</span> (s == NULL) {
            <span class="comment">// dispatch pipe message at beginning</span>
            <span class="keyword">continue</span>;
        }
        <span class="keyword">switch</span> (s-&gt;type) {
        <span class="keyword">case</span> SOCKET_TYPE_CONNECTING:
            <span class="keyword">return</span> report_connect(ss, s, result);
        <span class="keyword">case</span> SOCKET_TYPE_LISTEN:
            <span class="keyword">if</span> (report_accept(ss, s, result)) {
                <span class="keyword">return</span> SOCKET_ACCEPT;
            } 
            <span class="keyword">break</span>;
        <span class="keyword">case</span> SOCKET_TYPE_INVALID:
            fprintf(stderr, <span class="string">"socket-server: invalid socket\n"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            ...
        }
    }
}
&lt;!--￼<span class="number">37</span>--&gt;

<span class="comment">// skynet_socket.c</span>
<span class="keyword">static</span> <span class="keyword">struct</span> socket_server * SOCKET_SERVER = NULL;

<span class="keyword">void</span> 
skynet_socket_init() {
    SOCKET_SERVER = socket_server_create();
}

<span class="comment">// socket_server.c</span>
<span class="keyword">struct</span> socket_server * 
socket_server_create() {
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> fd[<span class="number">2</span>];
    poll_fd efd = sp_create();
    <span class="keyword">if</span> (sp_invalid(efd)) {
        fprintf(stderr, <span class="string">"socket-server: create event pool failed.\n"</span>);
        <span class="keyword">return</span> NULL;
    }

    <span class="comment">// 创建管道，用于其他线程向socket线程发送消息，这样能够轻松保证其他线程向socket线程发送数据包时的线程安全</span>
    <span class="keyword">if</span> (pipe(fd)) {
        sp_release(efd);
        fprintf(stderr, <span class="string">"socket-server: create socket pair failed.\n"</span>);
        <span class="keyword">return</span> NULL;
    }
    <span class="keyword">if</span> (sp_add(efd, fd[<span class="number">0</span>], NULL)) {
        <span class="comment">// add recvctrl_fd to event poll</span>
        fprintf(stderr, <span class="string">"socket-server: can't add server fd to event pool.\n"</span>);
        close(fd[<span class="number">0</span>]);
        close(fd[<span class="number">1</span>]);
        sp_release(efd);
        <span class="keyword">return</span> NULL;
    }

    <span class="keyword">struct</span> socket_server *ss = MALLOC(sizeof(*ss));
    ss-&gt;event_fd = efd;
    ss-&gt;recvctrl_fd = fd[<span class="number">0</span>];
    ss-&gt;sendctrl_fd = fd[<span class="number">1</span>];
    ss-&gt;checkctrl = <span class="number">1</span>;  <span class="comment">// checkctrl等于1的时候，表示本节点内其他线程有发送数据包到socket线程</span>

    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAX_SOCKET;i++) {
        <span class="keyword">struct</span> socket *s = &amp;ss-&gt;slot[i];
        s-&gt;type = SOCKET_TYPE_INVALID;
        clear_wb_list(&amp;s-&gt;high);
        clear_wb_list(&amp;s-&gt;low);
    }
    ss-&gt;alloc_id = <span class="number">0</span>;
    ss-&gt;event_n = <span class="number">0</span>;
    ss-&gt;event_index = <span class="number">0</span>;
    memset(&amp;ss-&gt;soi, <span class="number">0</span>, sizeof(ss-&gt;soi));
    FD_ZERO(&amp;ss-&gt;rfds);
    <span class="keyword">assert</span>(ss-&gt;recvctrl_fd &lt; FD_SETSIZE);

    <span class="keyword">return</span> ss;
}

<span class="comment">// socket_epoll.h</span>
<span class="keyword">static</span> <span class="keyword">int</span>
sp_create() {
    <span class="keyword">return</span> epoll_create(<span class="number">1024</span>);
}
<span class="string">``</span><span class="string">`

从初始化代码来看，我们可以知道skynet的网络层使用了epoll模型，epoll属于同步io，当没有任何一个fd能收到客户端发送过来的数据包，或者任何一个fd有要向客户端推送数据包时，那么socket线程将被阻塞，当有任意一个fd能够接收数据包或者发送数据包时，就会唤醒socket线程，并对数据包进行处理。不同于select和poll，当有事件触发时，epoll不需要轮询并测试所有的fd（效率为O(n)），只返回准备好的fd及事件(效率是O(1))。  
此外，这里需要对epoll_create的create作一个说明，这里的1024并非是epoll只能监听1024个fd，而是初始分配的内存大小为1024，当要epoll实例监听的fd超过1024以后，会重新分配内存以容纳更多的fd。新版本的linux中，epoll已经在内核中，自己管理初始的fd列表大小，这个值已经没有意义，但是仍然必须填&gt;0的值，目的是兼容老版本的操作系统内核。  
&gt; 引证来源：http://man7.org/linux/man-pages/man2/epoll_create.2.html
&gt; DESCRIPTION         top

&gt; epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8,
the size argument is ignored, but must be greater than zero; see
NOTES below.

&gt; epoll_create() returns a file descriptor referring to the new epoll
instance.  This file descriptor is used for all the subsequent calls
to the epoll interface.  When no longer required, the file descriptor
returned by epoll_create() should be closed by using close(2).  When
all file descriptors referring to an epoll instance have been closed,
the kernel destroys the instance and releases the associated

&gt; NOTES         
&gt; In the initial epoll_create() implementation, the size argument
informed the kernel of the number of file descriptors that the caller
expected to add to the epoll instance.  The kernel used this
information as a hint for the amount of space to initially allocate
in internal data structures describing events.  (If necessary, the
kernel would allocate more space if the caller's usage exceeded the
hint given in size.)  Nowadays, this hint is no longer required (the
kernel dynamically sizes the required data structures without needing
the hint), but size must still be greater than zero, in order to
ensure backward compatibility when new epoll applications are run on
older kernels.

此外，skynet的网络层，还在单个节点内使用管道，这里的目的是，其他线程向socket线程发送数据包，这样做的好处是，socket线程能够像处理网络消息一样，处理来自其他线程的请求，并且完全不用加任何锁，保证了线程安全，也简化了逻辑复杂度。  
再后面则是对socket列表的初始化操作，这里没什么好说的了。</span>
</code></pre><ol>
<li><p>skynet监听和绑定端口的流程<br> 我们要真正接收来自客户端的消息时，通常需要创建一个gate服务，用于接收从socket线程发送过来的消息，首先我们要通过gate，绑定和监听一个端口。这里，我们在gate创建阶段监听一个端口，在worker线程内，gate服务创建绑定了一个端口，并且监听了它，此时，gate服务（worker线程内）通过管道向socket线程发送了一个请求，向socket slot里添加一个专门用于监听端口的socket（类型为SOCKET_TYPE_LISTEN），并且在epoll里添加这个socket的监听事件，这样当有关于该socket的epoll事件触发时，由于epoll的event数据包含socket的指针，该socket对应的类型为SOCKET_TYPE_LISTEN，因此我们可以知道该epoll事件，其实是有一个连接可以建立了。在连接建立以后，socket线程会向gate服务发送一条消息，通知gate服务新建立连接socket的slot id，让gate自己处理。<br> <img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/005socket_listen.png" alt="image">  </p>
</li>
<li><p>skynet建立和客户端连接流程<br> 我们在创建了一个监听端口的socket并且为其添加epoll事件以后，当有客户端发送连接请求的时候，socket线程会accept他们，并在socket slot里添加新的socket，此时，socket线程也会向gate服务的次级消息队列，插入一个消息，告知它，有新的连接建立，并且告诉gate新创建socket在socket slot的id，gate接收到新连接建立事件后，会根据会创建一个lua服务–agent服务（这里忽略登陆验证的情况），并且以socket的slot id为key，agent服务地址为value存入一个table，以便于gate接收到消息的时候，通过socket slot id查找agent地址并将数据包转发给agent服务。此外，这里也以agent服务地址为key，socket slot id为value，将信息存入另一个table表，以便于agent要推送消息时，通过管道，将要下传的数据以及socket slot id一起发给socket线程，socket线程通过id，找到对应的socket指针，并将数据通过fd传给客户端。<br> <img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/006socket_accept.png" alt="image">  </p>
</li>
<li><p>skynet接收客户端消息流程<br> 由于单个skynet节点内，所有的socket都归gate服务管理，当socket收到数据包以后，就会往gate服务的次级消息队列，push数据包消息，gate在收到消息以后，首先会对数据进行分包和粘包处理，当收齐所有字节以后，又会向agent服务转发（向agent的次级消息队列push消息），最后agent会一个一个消费这些从客户端上传的请求。<br> <img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/007socket_recv.png" alt="image">  </p>
</li>
<li><p>服务端向客户端发送数据流程<br> agent服务向客户端发送消息时，直接通过管道，将数据包从worker线程发送往socket线程，socket线程收到后，会将数据包存入对应socket的write buffer中，最后再向客户端推送。<br> <img src="https://raw.githubusercontent.com/Manistein/Photos/master/DailyUse/skynet_study/008socket_send.png" alt="image">  </p>
</li>
</ol>
<h4 id="skynet的几个基本服务">skynet的几个基本服务</h4><p>我们可以在skynet/service/bootstrap.lua里看到skynet的基本lua服务启动流程，这里不再赘述。</p>
<h4 id="集群">集群</h4><p>这一部分，云风大侠已经说的很清楚了，这里就不敢班门弄斧。<br>如何使用查看<a href="https://github.com/cloudwu/skynet/wiki/Cluster" target="_blank" rel="external">Cluster</a><br>Cluster设计请查看<a href="http://blog.codingnow.com/2017/03/skynet_cluster.html" target="_blank" rel="external">skynet cluster 模块的设计与编码协议</a></p>
</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/02/ip客户端程序兼容IPV6和IPV4通信v6/" rel="next">客户端程序兼容IPV6和IPV4通信</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


            </div>

            

            
              <div class="comments" id="comments">
                
                  <div class="ds-thread" data-thread-key="2018/01/25/skynet源码赏析/"
                       data-title="" data-url="http://blog.shixbo.com/2018/01/25/skynet源码赏析/">
                  </div>
                
              </div>
            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars1.githubusercontent.com/u/32269?v=3&s=460" alt="Bobo" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Bobo</p>
        </div>
        <p class="site-description motion-element" itemprop="description">终于能搭建自己的博客，好开森！</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flesh0731" target="_blank">GitHub</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">友情链接</p>
            
              <span class="links-of-author-item">
              <a href="http://log.zvz.im/" target="_blank">zvz的blog</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#写在最前面"><span class="nav-number">1.</span> <span class="nav-text">写在最前面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对于skynet，需要屡清楚的几个问题"><span class="nav-number">2.</span> <span class="nav-text">对于skynet，需要屡清楚的几个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview"><span class="nav-number">3.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skynet基本结构"><span class="nav-number">4.</span> <span class="nav-text">skynet基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skynet的几个基本服务"><span class="nav-number">5.</span> <span class="nav-text">skynet的几个基本服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群"><span class="nav-number">6.</span> <span class="nav-text">集群</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bobo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shixbo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>


  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.4" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>








<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>
